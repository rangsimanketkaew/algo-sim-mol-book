% LaTeX source for ``Algorithms for Computer Simulation of Molecular Systems''
% Copyright (c) 2023 รังสิมันต์ เกษแก้ว (Rangsiman Ketkaew).

% License: Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)
% https://creativecommons.org/licenses/by-nc-nd/4.0/

\chapter{การพัฒนาซอฟต์แวร์สำหรับเคมีเชิงคำนวณ}
\label{ch:software_dev}

%----------------------------------------
\section{การเขียนโปรแกรมทางเคมีเชิงคำนวณ}
%----------------------------------------

ถ้าหากผู้อ่านอยากจะศึกษาการเขียนโปรแกรมทางเคมีเชิงคำนวณจะเริ่มยังไงดี เช่น ต้องการเขียนโปรแกรม Density Functional Theory (DFT)
หรือ Implement วิธีโครงสร้างเชิงอิเล็กทรอนิกส์ (Electronic Structure) ผมขอให้ความเห็นอย่างนี้ครับว่าการจะที่เขียนโปรแกรมทางเคมี%
คำนวณขึ้นมาสักโปรแกรมหนึ่งนั้นใช้เวลามากพอสมควรเพราะว่ามีรายละเอียดที่ซับซ้อนมาก (เวลาที่ใช้ในการเขียนนั้นขึ้นอยู่กับว่าเขียนคนเดียวหรือช่วย%
กันเขียนหลายคน) ดังนั้นผมแนะนำว่าสำหรับผู้ที่เพิ่งเริ่มต้นการเขียนโปรแกรมทางวิทยาศาสตร์ควรศึกษาจากโปรแกรมมาตรฐานที่ได้รับความนิยมอยู่แล้ว
ผมไม่ได้บอกว่าห้ามเขียนโปรแกรมใหม่เองแบบเริ่มจากศูนย์หรือ From Scratch แต่ถ้าหากว่าเราเริ่มต้นเรียนรู้จากโปรแกรมที่ได้รับความนิยมและใช้งาน%
กันอย่างแพร่หลายอยู่แล้วก็มีข้อดีดังนี้

\begin{itemize}[topsep=0pt]
  \item ประหยัดเวลา ไม่ต้องมานั่งศึกษาหรือเขียนโค้ดใหม่เองทั้งหมด

  \item ได้เรียนรู้วิธีการเขียนโค้ดที่มีประสิทธิภาพจากนักพัฒนาคนอื่น ๆ

  \item เป็นการต่อยอดและพัฒนาโปรแกรมนั้น ๆ ให้ดีขึ้นไปอีกเพราะเราไม่จำเป็นต้องมา Reinvent the Wheel

  \item เป็นการสร้างเครือข่ายนักวิจัยและความร่วมมือทางวิชาการในระดับนานาชาติ
\end{itemize}

\noindent อย่างไรก็ตามถ้าหากใครอยากจะเริ่มเขียนโปรแกรมเองนั้น (ไม่จำเป็นต้องเป็น DFT อย่างเดียว แต่รวมถึงวิธีการจำลองทางคอมพิวเตอร์อื่น ๆ
ด้วย เช่น Molecular Dynamics หรือ Monte Carlo) ก็มีข้อดีหลายข้อเหมือนกัน ดังนี้

\begin{itemize}[topsep=0pt]
  \item ได้ทำความเข้าใจการเขียนโปรแกรมอ้างอิงตามสมการทาง Electronic Structure

  \item ฝึกทักษะการเขียนโปรแกรมสำหรับการคำนวณทางวิทยาศาสตร์และได้เรียนรู้เทคนิคการประมาณค่าเชิงตัวเลข

  \item ได้ออกแบบโปรแกรมเองและ Implement วิธีใหม่ ๆ ที่โปรแกรมอื่นไม่มี

  \item ต่อยอดเป็นโปรแกรมในรูปแบบเชิงพานิชย์ได้เพราะว่ามีโปรแกรมทางเคมีคำนวณหลาย ๆ โปรแกรมที่ขาย License
\end{itemize}

ประเด็นหรือคำถามสำคัญคือ \enquote{ถ้าหากอยากจะเริ่มศึกษาโค้ดของวิธีการคำนวณทางเคมีควอนตัม เช่น โปรแกรม Density Functional
  Theory (DFT) ดี ๆ สักตัวนึงจะเริ่มจากไหนดี?} ความเห็นของผมคือแนะนำให้ศึกษาโปรแกรม PySCF โดยมีเหตุผลดังต่อไปนี้

\begin{itemize}[topsep=0pt]
  \item โปรแกรมมีประสิทธิภาพสูง ทำงานได้เร็วและให้ผลการคำนวณที่ถูกต้องและแม่นยำและยังคำนวณได้หลากหลายวิธี

  \item มีผู้ใช้งานเยอะเนื่องจากว่าโปรแกรม PySCF นั้นสามารถติดตั้งและใช้งานได้ง่าย เตรียมไฟล์ Input ได้ไม่ยุ่งยาก

  \item PySCF เขียนด้วย Python เกือบทั้งหมด (87\% เขียนด้วย Python, 12\% เป็นภาษา C ก็คือพวกไลบรารี่ต่าง ๆ ที่เอามาคำนวณ%
        ในส่วนที่ Python อาจจะคำนวณได้ช้า) ดังนั้นจึงง่ายต่อการทำความเข้าใจ

  \item มีทีมพัฒนาที่ใหญ่และแข็งแกร่ง ได้รับการสนับสนุนฟีเจอร์และแก้ไข Bug อย่างต่อเนื่อง
\end{itemize}

\noindent จากข้อ 1 ถ้าหากเราต้องการ Implement วิธีหรือเทคนิคใหม่ ๆ เข้าไปใน PySCF ก็ทำได้ง่ายเพราะว่าเขียนด้วยภาษา Python
นอกจากนี้โปรแกรมยังสามารถทำงานด้วย GPU ได้ด้วย (มี Plugin พิเศษชื่อว่า gpu2pyscf) ตัวโค้ดถูกเขียนและได้รับการปรับปรุงมาเป็นอย่างดี
(Well-written) มีการวางโครงสร้างของโปรแกรมที่เรียบร้อย แบ่ง Methods ต่าง ๆ ออกเป็น Module ที่ชัดเจนและมีการจัดวาง Function
ที่เหมาะสม สำหรับผู้อ่านที่สนใจโปรแกรม PySCF ก็ไปดูได้ที่ \url{https://github.com/pyscf/pyscf}

เมื่อเราเลือกโปรแกรมได้แล้ว ขั้นตอนต่อมาก็คือพยายามทำความเข้าใจทฤษฎีของหัวข้องานวิจัยที่เราต้องการศึกษา พยายามหาว่าเราสามารถพัฒนา%
วิธีนั้น ๆ ได้อย่างไรเพื่อที่จะปรับปรุงให้มีความถูกต้องในการคำนวณมากขึ้นหรือหากรณีที่ทฤษฎีนั้นยังไม่ครอบคลุม ขั้นตอนต่อไปคือหาวิธีการแก้ไข%
ปัญหาหรือ Solution สำหรับการปรับปรุงทฤษฎีนั้นแล้วเขียนออกมาเป็นสมการทางคณิตศาสตร์ที่เราจะนำไป Implement ได้ ขั้นตอนต่อไปก็คือ%
การวางแผนการเขียนโปรแกรมซึ่งสามารถทำได้ด้วยการเขียนโค้ดเทียมหรือ Pseudo Code ก่อนที่เราจะ Implement จริง ๆ โดยเราจะต้องคิดเกี่ยว%
กับการวางโครงสร้างหรือ Structure ของโปรแกรม เช่น แบ่งโปรแกรมออกเป็นโปรแกรมย่อย ๆ หลายส่วน เช่น แบ่งเป็น modules, functions,
classes, หรือ types โดยเราควรจะต้องคำนึงถึงการพัฒนาโปรแกรมต่อไปในอนาคตด้วยว่าโปรแกรมของเรานั้นสามารถที่จะรองรับฟีเจอร์ใหม่ ๆ
ที่นักพัฒนาคนอื่น ๆ จะเข้ามาช่วยพัฒนาเพิ่มเติมได้

หลังจากที่เรา Implement เข้าไปในโปรแกรมเสร็จเรียบร้อยแล้วเราควรจะต้องมีการตรวจสอบการทำงานของโปรแกรมหรือฟังก์ชันต่าง ๆ อย่างสม่ำเสมอ%
เพื่อตรวจสอบค่าที่ได้จากคำนวณว่ามีความถูกต้องและมีความสมเหตุสมผลมากน้อยแค่ไหน เมื่อได้ค่าการคำนวณที่ถูกต้องแล้วขั้นตอนสุดท้ายก็คือการ%
ปรับปรุงหรือทำความสะอาดโค้ดให้มีประสิทธิภาพและอ่านได้ง่ายขึ้น ในขั้นตอนนี้เราสามารถเรียนรู้ได้จากการศึกษาโค้ดที่นักพัฒนาคนอื่นเขียนไว้ก็ได้%
ว่าเขาเขียนอย่างไร ใช้วิธีหรือเทคนิคอะไรที่ทำให้โค้ดรันได้เร็วและมีประสิทธิภาพ นอกจากนี้ยังมีสิ่งอื่น ๆ ที่เราควรจะต้องทำด้วย เช่น เขียน Comment
หรือทำเอกสารประกอบการใช้งาน (Documentation) เพื่อที่ว่าตัวเราเองหรือนักพัฒนาคนอื่น ๆ ที่มาอ่านหรือแก้ไขโค้ดของเรานั้นสามารถทำความ%
เข้าใจโค้ดได้ง่ายและไม่ต้องมานั่งศึกษาเองจากศูนย์

%----------------------------------------
\section{การวางโครงสร้างโปรแกรม}
%----------------------------------------

การที่เราจะเขียนโปรแกรมคำนวณทางวิทยาศาสตร์นั้นควรที่จะต้องมีการวางแผนให้ดีเพราะว่าเมื่อเราเขียนโค้ดไปเรื่อย ๆ ตัวโปรแกรมของเราก็จะมี%
ขนาดที่ใหญ่ขึ้นและมีความซับซ้อนมากขึ้นด้วย ดังนั้นการวางโครงสร้างของโปรแกรมเพื่อให้รองรับฟังก์ชันหรือฟีเจอร์ใหม่ ๆ ที่อาจจะมีการเขียนโค้ดเพิ่ม%
เข้ามานั้นช่วยให้โปรแกรมนั้นมีความเป็นระเบียบและง่ายต่อการ Maintenance และไม่สร้างความปวดหัวให้กับนักพัฒนาคนอื่น ๆ ที่อาจจะเข้ามาพัฒนา%
โปรแกรมของเราต่อ (อาจจะสร้างความปวดหัวแต่ก็ไม่เยอะเท่ากับโปรแกรมที่มีการวางโครงสร้างที่ไม่ดี)

ผมขอยกตัวอย่างโปรแกรม CP2K ซึ่งเป็นโปรแกรมที่ผมใช้ในงานทำวิจัย ตัว Source Code ของ CP2K นั้นจะมีโฟลเดอร์ต่าง ๆ เช่น src/, docs/,
tests/, หรือ tools/ ซึ่งโฟลเดอร์เหล่านี้เก็บไฟล์ที่มีหน้าที่แตกต่างกันออกไป แต่โฟลเดอร์ที่น่าจะสำคัญที่สุดก็คือ src/ ซึ่งเก็บไฟล์โค้ดการทำงานหลัก%
ของตัวโปรแกรมเอาไว้ ส่วนโฟลเดอร์อื่น ๆ เช่น test เป็นโฟลเดอร์ที่เก็บไฟล์อินพุตและเอาต์พุตที่ไว้ใช้สำหรับการทดสอบโปรแกรมและเปรียบเทียบกับ%
ค่าผลลัพธ์จากการคำนวณว่าได้ค่าที่ถูกต้องและแม่นยำ ตัวโฟลเดอร์ src/ นั้นบางโปรแกรมก็มีขนาดหลายร้อยเมกะไบต์หรือบางโปรแกรมก็มีหลายกิกะไบต์
ขึ้นอยู่กับว่าตัวโปรแกรมนั้นซับซ้อนมากแค่ไหน ซึ่งความซับซ้อนของโปรแกรมนั้นอาจจะวัดได้ง่าย ๆ จากจำนวนของฟีเจอร์หรือวิธีการที่โปรแกรมสามารถ%
คำนวณได้ นอกจากนี้เรายังดูได้จากความซับซ้อนของการ Implementation เช่น ถ้าโปรแกรมสามารถทำงานแบบขนาด (Parallel) บน Distributed
Cluster ได้นั่นหมายความว่าโค้ดของโปรแกรมนั้นจะต้องมีการถูกปรับ (Optimized) ให้รองรับวิธี OpenMP หรือ Message-passing Interface
(MPI) ซึ่งก็จะซับซ้อนกว่าโค้ดของโปรแกรมทั่วไป นอกจากนี้แล้วยังมีอีกหนึ่งเหตุผลนั่นก็คือโปรแกรมนั้นใช้ Packages หรือ Library อื่นมากน้อยแค่ไหน
เพราะว่าในปัจจุบันนั้นการพัฒนาโปรแกรมทางวิทยาศาสตร์โดยเฉพาะเคมีควอนตัมนั้นเราก็มักจะไม่ได้เขียนส่วนประกอบต่าง ๆ ของโปรแกรมเองใหม่ทั้งหมด
(หรือที่เรียกว่าเขียนแบบเริ่มจากศูนย์หรือ From Scratch เลย) นั่นก็เพราะว่าแต่ละส่วนหรือองค์ประกอบของการคำนวณนั้นมีความซับซ้อนมาก ดังนั้น%
จึงมีนักวิจัยที่สร้าง Library สำหรับการคำนวณบางอย่างไว้ให้เราแล้วซึ่งเราก็สามารถหยิบมาใช้ได้เลย การคำนวณบางอย่างที่มีความซับซ้อนนั้น เช่น
การคำนวณ Matrix Multiplication หรือการคำนวณ One-electron Integral และ Two-electron Integral รวมไปถึง Library
เฉพาะทาง เช่น Library ที่มีชุดฟังก์ชันของ DFT Functional ให้เรานำมาใช้งานได้เลย เรียกได้ว่าทำให้ชีวิตนักเคมีทฤษฎีที่ต้องพัฒนาโปรแกรมนั้น%
นั้นประหยัดเวลาชีวิตไปได้เยอะมาก โปรแกรม CP2K ซึ่งเป็นอีกหนึ่งโปรแกรมที่ถูกพัฒนาขึ้นโดยใช้ประโยชน์จาก Library อื่น ๆ มีโครงสร้างตามภาพ%
ด้านล่าง

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.7\linewidth]{fig/cp2k-lib.jpg}
  \caption{ไลบรารี่ที่โปรแกรม CP2K ใช้ในการช่วยคำนวณ}
  \label{fig:cp2k_lib}
\end{figure}

ผมจะมาอธิบายบาง Library ที่สำคัญ ๆ ของ CP2K ใช้ ดังนี้

\begin{description}
  \item[GNU] แน่นอนว่าเราต้องคอมไพล์ Source Code ดังนั้นเราจะต้องใช้ตัวคอมไพล์ (Compiler) ซึ่ง CP2K เลือกใช้ GNU เป็น Compiler

  \item[OpenBLAS กับ ScaLAPACK]  สำหรับ Linear Algebraic Calculation เช่น Matrix-vector, Matrix-matrix Multiplication

  \item[MPICH] อยากจะรันโปรแกรมแบบขนานโดยใช้ MPI ก็ต้องหา Implementation ที่จะมารันโค้ดของเรา ซึ่ง MPICH ก็เป็นหนึ่งใน
    Implementation ของ MPI ที่ CP2K เลือกใช้

  \item[FFTW] สำหรับทำฟูเรียร์ทรานฟอร์มในการคำนวณ DFT หรือแปลงจาก Real Space ไปเป็น Reciprocal Space สำหรับการคำนวณ
    Electrostatics โดยใช้ Plane Wave Electron Density

  \item[LIBXC] เป็น Library ที่ให้เราสามารถนำ DFT Functional มาใช้ได้เลยโดยไม่ต้อง Implement เอง
\end{description}

สรุปก็คือจะเห็นได้ว่าการเขียนโค้ดของโปรแกรมเคมีควอนตัมนั้นมีความซับซ้อนมากดังนั้นเรามีสองทางเลือกคือ

\begin{enumerate}[topsep=0pt,noitemsep]
  \setlength\itemsep{1em}
  \item ใช้ Library ที่มีอยู่แล้วสำหรับการทำงานเฉพาะจุด

  \item เขียนโค้ดทั้งหมดเองเลย
\end{enumerate}

แน่นอนว่าถ้าเราเลือกวิธีแรกก็จะประหยัดเวลาไปได้เยอะมากและเวลาที่เราคอมไพล์โปรแกรมก็ขอแค่ Link กับ Library ต่าง ๆ ก็รันโปรแกรมได้แล้ว%
และทำให้ขนาดของตัวโปรแกรมของเรา (ขนาดของ Binary Files) นั้นมีขนาดไม่ใหญ่มากเกินไปด้วย (เช่นหลักสิบ-ร้อยเมกะไบต์)

อย่างไรก็ตามโปรแกรมสำหรับจำลองระบบโมเลกุลหลาย ๆ โปรแกรมก็ไม่ได้ใช้ Library เหล่านี้และเลือกใช้วิธีที่ 2 ก็คือการเขียนโค้ดสำหรับการ%
คำนวณส่วนต่าง ๆ เองเลยเนื่องด้วยเหตุหลายข้อ เช่น การเขียนโค้ดทั้งหมดภายใน Framework โปรแกรมเดียวกันนั้นจะทำให้โค้ดมีประสิทธิภาพและ%
ทำงานร่วมกันได้ดี (Compatibility), ง่ายต่อการดูแลรักษาและปรับปรุงโค้ดเพราะว่า Developers นั้นรู้และเข้าใจการทำงานของโค้ดทั้งหมด,
ถึงแม้ว่าโปรแกรมที่เขียนโค้ดทั้งหมดเองเมื่อถูกคอมไพล์แล้วจะได้ออกมาเป็น Binary File ที่มีขนาดนั้นใหญ่มาก ๆ เช่น หลายกิกะไบต์ แต่ว่าก็มี%
ความคล่องตัวในการใช้งานเพราะว่าไม่ต้องติดตั้ง Library อื่น ๆ เพิ่มเติม

นอกจากนี้แล้วการที่ใช้ Library หลาย ๆ ตัวแบบนี้ก็มีจุดอ่อนบางข้อที่เราควรจะต้องรู้ไว้นั่นก็คือการเข้ากันได้ (Compatibility) ระหว่าง Library
หรือเวอร์ชันซึ่งก็อาจจะทำให้เราปวดหัวได้ถ้าหากว่า Library บางตัวมีการอัพเดทเวอร์ชันใหม่แล้ว Conflict กับ Library ตัวอื่น

%----------------------------------------
\section{ทักษะและเครื่องมือสำหรับการเขียนโปรแกรมคำนวณทางวิทยาศาสตร์}
%----------------------------------------

\noindent \textbf{ภาษาคอมพิวเตอร์}

\begin{itemize}[topsep=0pt]
  \item ภาษาสคริปต์ (Scripting Language): Bash, Python

  \item ภาษาระดับล่างที่เป็น Object-Oriented Programming: C++, Fortran

  \item ภาษาเชิงสัญลักษณ์ (Symbolic Programming): Mathematica, SymPy
\end{itemize}

\noindent \textbf{โปรแกรมสำหรับการเขียนโค้ด}

\begin{itemize}[topsep=0pt]
  \item Vi/Vim, Nano

  \item VS Code, Atom, Eclipse, Sublime, Notepad++
\end{itemize}

\noindent \textbf{พื้นฐานการเขียนโปรแกรม}

\begin{itemize}[topsep=0pt]
  \item ชนิดของตัวแปร (Variable Types)

  \item ตัวดำเนินการหรือโอเปอร์เรเตอร์ (Operator)

  \item Control Statements เช่น For, Do, If-Else, Case

  \item ฟังก์ชัน (Function)

  \item Vairable Scope และ Reference Types

  \item คลาส (Class) และวัตถุ (Objects)
\end{itemize}

\noindent \textbf{ภาษาคอมพิวเตอร์ระดับล่าง}

\noindent \underline{ภาษา C}

\begin{itemize}[topsep=0pt]
  \item Function, Pointer, Storage Class

  \item Enum, Struct, Union

  \item Preprocessor

  \item Operator, Memory Management, Array

  \item การจัดการไฟล์ (File Handling)
\end{itemize}

\noindent \textbf{ภาษาคอมพิวเตอร์ระดับสูง}

\noindent \underline{ภาษา Python}

\begin{itemize}[topsep=0pt]
  \item Pip และ Conda: ตัวช่วยจัดการไลบรารี่ของ Python

  \item NumPy: จัดการและคำนวณ Array (เวกเตอร์, เมทริกซ์)

  \item Numba: JIT Compiler สำหรับ NumPy

  \item Jax: ทำ Autograd (Gradient Comptuation) สำหรับ NumPy Array

  \item SciPy: ไลบรารี่ที่รวมรวบฟังก์ชันทางคณิตศาสตร์และวิทยาศาสตร์

  \item Scikit-learn: ไลบรารี่สำหรับทำสถิติ, Optimization, และ Curve Fitting รวมถึง Machine Learning

  \item Matplotlib, Plotly: พลอตกราฟ

  \item Theano: คำนวณเชิงตัวเลข (Numerical Computation)

  \item SCOOP: โมดูลสำหรับการทำโปรแกรมแบบขนาน (Parallel Programming)

  \item NetworkX: ไลบรารี่สำหรับ Graph
\end{itemize}

\noindent \underline{ภาษา C++}

\begin{itemize}[topsep=0pt]
  \item Type of variable: signed, unsigned, long, double, etc.

  \item Loops, conditional Statement

  \item Standard libraries: vector, rand

  \item Understanding header (`.hpp`) and source file (\texttt{.cpp} or \texttt{.cc})

  \item Preprocessor (\texttt{\#if}, \texttt{\#ifdef}, \texttt{\#ifndef}, \texttt{\#define}, etc.)

  \item Function, class, struct, template

  \item Declaration

  \item namespace, const, attribute, pointer, pass by reference, static_assert

  \item Initialization

  \item casting, lambda expression, encapsulation, file handling, exception handling
\end{itemize}

\noindent \underline{ภาษา Fortran}

\begin{itemize}[topsep=0pt]
  \item เรียนรู้ภาษา Fortran ที่เป็น Modern Fortran ตั้งแต่เวอร์ชัน 2003 เป็นต้นไป

  \item โมดูล (Module), โปรแกรมย่อยหรือซับรูทีน (Subroutine), ฟังก์ชัน (Function)

  \item Array ทั้งแบบที่ปรับเปลี่ยนได้ (Allocatable) และแบบหลายมิติ (Multidimentional)

  \item Operator Overloading, Flow control

  \item Derived Type

  \item Callback

  \item การเขียนโปรแกรมเชื่อมโยงกับภาษาอื่น เช่น Python หรือ C++

  \item การใช้ GNU Library ในการคอมไพล์

  \item การจัดการหน่วยความจำ (Memory Allocation): Stack, Heap, Global Memory
\end{itemize}

\noindent \underline{ไลบรารี่สำหรับการคำนวณทางคณิตศาสตร์}

\begin{itemize}[topsep=0pt]
  \item BLAS (OpenBLAS)

  \item LAPACK: สำหรับคำนวณ Linear Algebra

  \item ScaLAPACK: เป็น LAPACK สำหรับซุปเปอร์คอมพิวเตอร์

  \item Intel MKL (Intel oneAPI)

  \item FFTW: สำหรับคำนวณ Discrete Fourier Transform ในหนึ่งมิติหรือมากกว่าหนึ่งมิติก็ได้

  \item Eigen: สำหรับคำนวณ Linear Algebra

  \item Boost: ไลบรารี่ที่รวบรวมฟังก์ชันต่าง ๆ สำหรับช่วยเขียนโปรแกรมภาษา C++ เช่น regex, serialization
\end{itemize}

\noindent \underline{เครื่องมือช่วยการพัฒนาซอฟต์แวร์}

\begin{itemize}[topsep=0pt]
  \item การทำ Code Optimization

  \item การทำ Benchmarking และ Scaling

  \item ความซับซ้อนเชิงการคำนวณ (Computational Complexity)

  \item Static และ Dynamic Libraries

  \item คอมไพเลอร์ Compiling (g++, gcc) และ Linking (ld)

  \item เครื่องมือสำหรับช่วยการคอมไพล์โค้ด: autoconf, configure, make, cmake, automake

  \item เครื่องมือสำหรับช่วยการ Debug: gdb สำหรับการ Debug ทั่วไปและ Valgrind สำหรับการวิเคราะห์ Memory Leak

  \item การทำ Source Code Control: Git (GitHub และ GitLab)

  \item การทำ Documentation: Sphinx (สำหรับ markdown และ reStructuredText), Doxygen
\end{itemize}

\noindent \underline{ไลบรารี่สำหรับเคมีควอนตัม}

\begin{itemize}[topsep=0pt]
  \item libxc: ไลบรารี่ที่รวบรวม XC Function สำหรับ DFT ซึ่งเราสามารถนำมาใช้งานได้เลย

  \item libint: ไลบรารี่ที่ช่วยในการคำนวณ Gaussian Integrals

  \item libcint: ไลบรารี่ที่ช่วยในการคำนวณ GTO Integrals
\end{itemize}

%----------------------------------------
\section{เขียนโปรแกรมวิเคราะห์ Molecular Geometry (ภาษา C++)}
%----------------------------------------

โปรแกรมแรกที่ผู้อ่านจะได้ศึกษาและฝึกเขียนตามก็คือโปรแกรมสำหรับวิเคราะห์เรขาคณิตเชิงโครงสร้าง Structural Geometry ของโมเลกุล
โดยเราจะใช้ภาษา C++ กันครับ ซึ่งภาษา C++ นั้นเป็นภาษาที่มีประสิทธิภาพสูงมากและถูกใช้อย่างแพร่หลายในการทำงานวิจัยเคมีควอนตัม
(รวมถึงสาขาอื่น ๆ ด้วย) และโปรแกรมสำหรับการวิเคราะห์อันนี้ไม่มีความซับซ้อนมาก

\noindent \bful{Step 1: อ่านไฟล์ Coordinates}

\vspace{5pt}

\begin{lstlisting}[style=MyC++]
#include <iostream>
#include <fstream>
#include <iomanip>
#include <cstdio>

using namespace std;

int main() 
{
  ifstream input("geom.dat");

  int natom;
  input >> natom;

  int *zval = new int[natom];
  double *x = new double[natom];
  double *y = new double[natom];
  double *z = new double[natom];

  for(int i=0; i < natom; i++)
    input >> zval[i] >> x[i] >> y[i] >> z[i];
  
  input.close();

  cout << "Number of atoms: " << natom << endl;
  cout << "Input Cartesian coordinates:\n";
  for(int i=0; i < natom; i++)
    printf("%d %20.12f %20.12f %20.12f\n", (int) zval[i], x[i], y[i], z[i]);

  delete[] zval;
  delete[] x;  delete[] y;  delete[] z;

  return 0;
}
\end{lstlisting}

\vspace{5pt}

จากตัวอย่างโค้ดด้านบนนั้นเริ่มการทำงานด้วยการอ่านไฟล์ Coordinates ของอะตอมในโมเลกุลซึ่งมีหน่วยคือ bohr โดยผู้อ่านอาจจะลองใช้ตัวอย่าง%
โมเลกุลเล็ก ๆ เช่น Acetaldehyde ซึ่งมี Coordinates ดังนี้

\begin{Verbatim}[frame=single]
  7
  6  0.000000000000     0.000000000000     0.000000000000
  6  0.000000000000     0.000000000000     2.845112131228
  8  1.899115961744     0.000000000000     4.139062527233
  1 -1.894048308506     0.000000000000     3.747688672216
  1  1.942500819960     0.000000000000    -0.701145981971
  1 -1.007295466862    -1.669971842687    -0.705916966833
  1 -1.007295466862     1.669971842687    -0.705916966833
\end{Verbatim}

\noindent โดยที่เลข 7 ในบรรทัดแรกนั้นคือจำนวนอะตอมและบรรทัดที่เหลือนั้นคือพิกัดตำแหน่ง x, y, z ของอะตอมแต่ละตัว เมื่อโปรแกรมเปิดไฟล์%
แล้วสิ่งที่จะทำถัดไปก็คือการอ่านข้อมูลแต่ละบรรทัดและเก็บข้อมูลไว้ จริง ๆ แล้วเราสามารถ Simplify โค้ดตัวอย่างอันนี้ให้มีความเป็นระเบียบมากขึ้น%
โดยการใช้ Class เช่น เราสามารถสร้างไฟล์ header ที่ชื่อ \inlinehighlight{molecule.h} แล้วทำการเรียกใช้งาน Class ในไฟล์โปรแกรม
\inlinehighlight{molecule.cpp} ได้ดังนี้

\vspace{5pt}

\begin{lstlisting}[style=MyC++]
#include "molecule.h"
#include <iostream>
#include <fstream>
#include <iomanip>
#include <cstdio>

using namespace std;

int main()
{
  Molecule mol("geom.dat", 0);

  cout << "Number of atoms: " << mol.natom << endl;
  cout << "Input Cartesian coordinates:\n";
  mol.print_geom();

  return 0;
}
\end{lstlisting}

\vspace{5pt}

\noindent ทีนี้สิ่งที่ผมอยากให้ผู้อ่านทำก็คือลองฝึกเขียนโค้ดของไฟล์ \inlinehighlight{molecule.h} โดยดัดแปลงจากโค้ดด้านบนครับ

\noindent \bful{Step 2: คำนวณความยาวพันธะ (Bond Lengths)}

คำนวณระยะห่างระหว่างอะตอม (Interatomic Distances) โดยใช้สมการดังต่อไปนี้

\begin{equation}
  R_{ij}
  =
  \sqrt{
    (x_{i} - x_{j})^{2}
    + (y_{i} - y_{j})^{2}
    + (z_{i} - z_{j})^{2}
  }
\end{equation}

\noindent โดยที่ $x, y, z$ คือ Cartesian Coordinates และ $i$ กับ $j$ คือเลข Index ของอะตอม

สำหรับการเขียนโปรแกรมเพื่อคำนวณ Distance นั้นเราจะต้องคำนึงถึงการจัดการหน่วยความจำ (Memory Allocation) ด้วยเพื่อให้โปรแกรมของเรา%
นั้นมีประสิทธิภาพมากที่สุดซึ่งนั่นก็จะเกี่ยวข้องกับการเลือกวิธีในการเก็บข้อมูลของระยะห่างระหว่างอะตอม ในการหาความยาวระหว่างอะตอมของทุก ๆ
คู่นั้นสามารถใช้เมทริกซ์มาเก็บข้อมูลได้ซึ่งขนาดของเมทริกซ์จะเป็น $N \times N$ โดยที่ $N$ คือจำนวนอะตอม ในการใช้เมทริกซ์นั้นเราจำเป็นที่%
จะต้องจัดสรร (Allocate) หน่วยความจำซึ่งทำได้สองวิธีคือ

\noindent $\bullet$ 1. ใช้ Static Two-Dimensional Array

\vspace{5pt}

\begin{lstlisting}[style=MyC++]
double R[50][50];
\end{lstlisting}

\vspace{5pt}

\noindent $\bullet$ 2. ใช้ Dynamic Allocation โดยการใช้คลาส \inlinehighlight{Molecule}

\vspace{5pt}

\begin{lstlisting}[style=MyC++]
double **R = new double* [mol.natom];
for(int i=0; i < mol.natom; i++)
  R[i] = new double[mol.natom];
\end{lstlisting}

\vspace{5pt}

\noindent แล้วก็อย่าลืมลบหน่วยความจำหลังจากที่คำนวณเสร็จแล้วด้วย ดังนี้

\vspace{5pt}

\begin{lstlisting}[style=MyC++]
for(int i=0; i < mol.natom; i++)
  delete[] R[i];
delete[] R;
\end{lstlisting}

\vspace{5pt}

ขั้นตอนต่อไปก็คือการสร้างเมทริกซ์ขึ้นมาซึ่งสามารถทำได้โดยใช้ For Loop ในการวนไปเรื่อย ๆ ตามเลข Index ของอะตอม

\vspace{5pt}

\noindent แล้วก็อย่าลืมลบหน่วยความจำหลังจากที่คำนวณเสร็จแล้วด้วย ดังนี้

\vspace{5pt}

\begin{lstlisting}[style=MyC++]
...
#include <cmath>
...

for(int i=0; i < mol.natom; i++) {
  for(int j=0; j < mol.natom; j++) {
      R[i][j] = 
        sqrt(
          (mol.geom[i][0]-mol.geom[j][0])*(mol.geom[i][0]-mol.geom[j][0])
        + (mol.geom[i][1]-mol.geom[j][1])*(mol.geom[i][1]-mol.geom[j][1])
        + (mol.geom[i][2]-mol.geom[j][2])*(mol.geom[i][2]-mol.geom[j][2]) 
        );
  }
}
\end{lstlisting}

\vspace{5pt}

ลำดับต่อไปคือการแสดงค่าความยาวที่คำนวณได้โดยเราก็จะใช้ For Loop เหมือนเดิม

\vspace{5pt}

\begin{lstlisting}[style=MyC++]
for(int i=0; i < mol.natom; i++)
  for(int j=0; j < i; j++)
    printf("%d %d %8.5f\n", i, j, R[i][j]);
\end{lstlisting}

\vspace{5pt}

ขั้นตอนสุดท้ายคือการทำให้โค้ดนั้นมีความเรียบร้อยและมีประสิทธิภาพมากขึ้น โดยเราสามารถนำโค้ดด้านบนที่เราได้เขียนไว้สร้างเป็นฟังก์ชันใหม่ที่ชื่อว่า
\ih{bond()} ในคลาส \ih{Molecule} ได้ดังนี้

\vspace{5pt}

\begin{lstlisting}[style=MyC++]
double Molecule::bond(int a, int b)
{
  return sqrt( (geom[a][0]-geom[b][0])*(geom[a][0]-geom[b][0])
              + (geom[a][1]-geom[b][1])*(geom[a][1]-geom[b][1])
              + (geom[a][2]-geom[b][2])*(geom[a][2]-geom[b][2]) );
}
\end{lstlisting}

\vspace{5pt}

แล้วก็โปรแกรมของเราก็จะมีหน้าตาเป็นแบบนี้

\vspace{5pt}

\begin{lstlisting}[style=MyC++]
#include "molecule.h"
#include <iostream>
#include <fstream>
#include <iomanip>
#include <cstdio>
#include <cmath>

using namespace std;
  
int main()
{
  Molecule mol("geom.dat", 0);
  
  cout << "Number of atoms: " << mol.natom << endl;
  cout << "Input Cartesian coordinates:\n";
  mol.print_geom();
  
  cout << "\nInteratomic distances (bohr):\n";
  for(int i=0; i < mol.natom; i++)
    for(int j=0; j < i; j++)
      printf("%d %d %8.5f\n", i, j, mol.bond(i,j));
      
  return 0;
}
\end{lstlisting}

\vspace{5pt}

\noindent ซึ่งก็จะมีเอาต์พุตดังต่อไปนี้

\vspace{5pt}

\begin{lstlisting}[style=MyC++]
Number of atoms: 7
Input Cartesian coordinates:
6     0.000000000000     0.000000000000     0.000000000000
6     0.000000000000     0.000000000000     2.845112131228
8     1.899115961744     0.000000000000     4.139062527233
1    -1.894048308506     0.000000000000     3.747688672216
1     1.942500819960     0.000000000000    -0.701145981971
1    -1.007295466862    -1.669971842687    -0.705916966833
1    -1.007295466862     1.669971842687    -0.705916966833

Interatomic distances (bohr):
1 0  2.84511
2 0  4.55395
2 1  2.29803
3 0  4.19912
3 1  2.09811
3 2  3.81330
4 0  2.06517
4 1  4.04342
4 2  4.84040
4 3  5.87463
5 0  2.07407
5 1  4.05133
5 2  5.89151
5 3  4.83836
5 4  3.38971
6 0  2.07407
6 1  4.05133
6 2  5.89151
6 3  4.83836
6 4  3.38971
6 5  3.33994
\end{lstlisting}

\vspace{5pt}

\noindent โดยที่ \ih{bond()} คือ Member Function ของ \ih{Molecule} ซึ่งเราสามารถเรียกใช้ข้อมูลของ Geometry (Coordinates)
ได้ผ่าน \ih{geom} โดยไม่จำเป็นต้องเรียกใช้ผ่าน \ih{mol.geom}

\noindent \bful{Step 3: คำนวณมุมพันธะ (Bond Angles)}

เราสามารถคำนวณมุมพันธะทุกมุมที่เป็นไปได้ทั้งหมดของโมเลกุล (ระหว่างอะตอม $i, j, k$) $\phi_{ijk}$ ได้ด้วยสมการดังต่อไปนี้

\begin{equation}
  \label{eq:cos_bond_angle}
  \cos \phi_{ijk} = \tilde{e}_{ji} \cdot \tilde{e}_{jk}
\end{equation}

\noindent โดยที่ $e_{ij}$ คือเวกเตอร์หนึ่งหน่วย (Unit Vector) ระหว่างอะตอมซึ่งสามารถคำนวณได้ด้วยสมการดังต่อไปนี้

\begin{align*}
  e^{x}_{ij}
  = \frac{
    -(x_{i} - x_{j})
  }
  {
    R_{ij}
  } \\
  e^{y}_{ij}
  = \frac{
    -(y_{i} - y_{j})
  }
  {
    R_{ij}
  } \\
  e^{z}_{ij}
  = \frac{
    -(z_{i} - z_{j})
  }
  {
    R_{ij}
  }
\end{align*}

\vspace{5pt}

โดยเราจะสร้างฟังก์ชันสำหรับคำนวณมุมพันธะซึ่งก็คือ Inverse ของฟังก์ชัน Cosine ของสมการที่ \eqref{eq:cos_bond_angle} แล้วเพิ่มฟังก์ชัน%
นี้เข้าไปในไฟล์ \ih{molecule.cpp} ดังนี้

\vspace{5pt}

\begin{lstlisting}[style=MyC++]
// Returns the value of the unit vector between atoms a and b
// in the cart direction (cart=0=x, cart=1=y, cart=2=z)
double Molecule::unit(int cart, int a, int b)
{
  return -(geom[a][cart]-geom[b][cart])/bond(a,b);
}

// Returns the angle between atoms a, b, and c in radians
double Molecule::angle(int a, int b, int c)
{
  return acos(unit(0,b,a) * unit(0,b,c) + unit(1,b,a) * unit(1,b,c) + unit(2,b,a) * unit(2,b,c));
}
\end{lstlisting}

\vspace{5pt}

\noindent นอกจากนี้เราจะต้องเพิ่ม Declaration ของ Member Function เข้าไปในไฟล์ \ih{molecule.h} ด้วย ดังนี้

\vspace{5pt}

\begin{lstlisting}[style=MyC++]
#include <string>

using namespace std;

class Molecule
{
  public:
    int natom;
    int charge;
    int *zvals;
    double **geom;
    string point_group;

    void print_geom();
    void rotate(double phi);
    void translate(double x, double y, double z);
    double bond(int atom1, int atom2);
    double angle(int atom1, int atom2, int atom3);
    double torsion(int atom1, int atom2, int atom3, int atom4);
    double unit(int cart, int atom1, int atom2);

    Molecule(const char *filename, int q);
    ~Molecule();
};
\end{lstlisting}

\vspace{5pt}

แล้วโปรแกรมสำหรับคำนวณมุมพันธะที่สมบูรณ์นั้นจะมีหน้าตาแบบนี้

\vspace{5pt}

\begin{lstlisting}[style=MyC++]
#include "molecule.h"
#include <iostream>
#include <fstream>
#include <iomanip>
#include <cstdio>
#include <cmath>

using namespace std;
  
int main()
{
  Molecule mol("geom.dat", 0);
  
  cout << "Number of atoms: " << mol.natom << endl;
  cout << "Input Cartesian coordinates:\n";
  mol.print_geom();

  cout << "\nBond angles:\n";
  for(int i=0; i < mol.natom; i++) {
    for(int j=0; j < i; j++) {
      for(int k=0; k < j; k++) {
        if(mol.bond(i,j) < 4.0 && mol.bond(j,k) < 4.0)
          printf("%2d-%2d-%2d %10.6f\n", i, j, k, mol.angle(i,j,k)*(180.0/acos(-1.0)));
      }
    }
  }

  return 0;
}
\end{lstlisting}

\vspace{5pt}

\noindent โดยที่เราใช้ \cppinline{acos(-1.0)} ในการประมาณค่า $\pi$

เมื่อเรารันโปรแกรมด้านบนจะได้เอาต์พุตแบบนี้

\vspace{5pt}

\begin{lstlisting}
Number of atoms: 7
Input Cartesian coordinates:
6     0.000000000000     0.000000000000     0.000000000000
6     0.000000000000     0.000000000000     2.845112131228
8     1.899115961744     0.000000000000     4.139062527233
1    -1.894048308506     0.000000000000     3.747688672216
1     1.942500819960     0.000000000000    -0.701145981971
1    -1.007295466862    -1.669971842687    -0.705916966833
1    -1.007295466862     1.669971842687    -0.705916966833

Bond angles:
  2- 1- 0 124.268308
  3- 1- 0 115.479341
  3- 2- 1  28.377448
  5- 4- 0  35.109529
  6- 4- 0  35.109529
  6- 5- 0  36.373677
  6- 5- 4  60.484476
\end{lstlisting}

\vspace{5pt}

\noindent \bful{Step 4: คำนวณมุมบิด (Torsion หรือ Dihedral Angles)}

พารามิเตอร์ลำดับต่อมาที่เราจะคำนวณก็คือมุมบิด (Torsion Angle) สำหรับมุมบิดของอะตอม 4 อะตอมใด ๆ ในโมเลกุล $i, j, k, l$ นั้นมี%
สมการในการคำนวณคือ

\begin{equation}
  \cos \tau_{ijkl}
  =
  \frac{
    (\tilde{e}_{ij} \times \tilde{e}_{jk})
    \cdot
    (\tilde{e}_{jk} \times \tilde{e}_{kl})
  }
  {
    \sin \theta_{ijk}
    \sin \theta_{jkl}
  }
\end{equation}

\noindent สิ่งที่ต้องระวังในการคำนวณ Torsion Angle ก็คือเครื่องหมายของมุมซึ่งจะเป็นบวกหรือลบนั้นก็คือขึ้นอยู่กับว่าเวกเตอร์นั้นมีทิศทางไปทาง%
ไหนเมื่อเทียบกับระนาบ

\begin{itemize}[topsep=0pt,noitemsep]
  \setlength\itemsep{1em}
  \item มุมบิดของอะตอม $i-j-k-l$ เป็นบวกเมื่อเวกเตอร์ตามแนวอะตอม $k-l$ นั้นวางตัวไปทางด้านขวาของระนาบที่สร้างจากอะตอม $i-j-k$
        เมื่อมองจากทิศทางของเวกเตอร์ $j-k$

  \item มุมบิดของอะตอม $i-j-k-l$ เป็นลบเมื่อเวกเตอร์ตามแนวอะตอม $k-l$ นั้นวางตัวไปทางด้านซ้ายของระนาบที่สร้างจากอะตอม $i-j-k$
        เมื่อมองจากทิศทางของเวกเตอร์ $j-k$
\end{itemize}

\vspace{5pt}

โปรแกรมสำหรับคำนวณ Torsion Angle นั้นมีดังนี้ เริ่มต้นด้วยการสร้าง Member Function ของคลาส \ih{Molecule}

\vspace{5pt}

\begin{lstlisting}[style=MyC++]
// Computes the angle between planes a-b-c and b-c-d
double Molecule::torsion(int a, int b, int c, int d)
{
  double eabc_x = (unit(1,b,a)*unit(2,b,c) - unit(2,b,a)*unit(1,b,c));
  double eabc_y = (unit(2,b,a)*unit(0,b,c) - unit(0,b,a)*unit(2,b,c));
  double eabc_z = (unit(0,b,a)*unit(1,b,c) - unit(1,b,a)*unit(0,b,c));

  double ebcd_x = (unit(1,c,b)*unit(2,c,d) - unit(2,c,b)*unit(1,c,d));
  double ebcd_y = (unit(2,c,b)*unit(0,c,d) - unit(0,c,b)*unit(2,c,d));
  double ebcd_z = (unit(0,c,b)*unit(1,c,d) - unit(1,c,b)*unit(0,c,d));

  double exx = eabc_x * ebcd_x;
  double eyy = eabc_y * ebcd_y;
  double ezz = eabc_z * ebcd_z;

  double tau = (exx + eyy + ezz)/(sin(angle(a,b,c)) * sin(angle(b,c,d)));

  if(tau < -1.0) tau = acos(-1.0);
  else if(tau > 1.0) tau = acos(1.0);
  else tau = acos(tau);

  // Compute the sign of the torsion 
  double cross_x = eabc_y * ebcd_z - eabc_z * ebcd_y;
  double cross_y = eabc_z * ebcd_x - eabc_x * ebcd_z;
  double cross_z = eabc_x * ebcd_y - eabc_y * ebcd_x;
  double norm = cross_x*cross_x + cross_y*cross_y + cross_z*cross_z;
  cross_x /= norm;
  cross_y /= norm;
  cross_z /= norm;
  double sign = 1.0;
  double dot = cross_x*unit(0,b,c)+cross_y*unit(1,b,c)+cross_z*unit(2,b,c);
  if(dot < 0.0) sign = -1.0;

  return tau*sign;
}
\end{lstlisting}

\vspace{5pt}

แล้วเราก็เรียกใช้ฟังก์ชันใหม่ที่เราเพิ่งสร้างไว้ในโปรแกรมหลักของเราได้ดังนี้

\vspace{5pt}

\begin{lstlisting}[style=MyC++]
#include <iostream>
#include <fstream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include "molecule.h"

using namespace std;

int main()
{
  Molecule mol("geom.dat", 0);

  cout << "Number of atoms: " << mol.natom << endl;
  cout << "Input Cartesian coordinates:\n";
  mol.print_geom();

  cout << "\nTorsional angles:\n";
  for(int i=0; i < mol.natom; i++) {
    for(int j=0; j < i; j++) {
      for(int k=0; k < j; k++) {
        for(int l=0; l < k; l++) {
          if(mol.bond(i,j) < 4.0 && mol.bond(j,k) < 4.0 && mol.bond(k,l) < 4.0)
            printf("%2d-%2d-%2d-%2d %10.6f\n", i, j, k, l, mol.torsion(i,j,k,l)*(180.0/acos(-1.0)));
        }
      }
    }
  }

  return 0;
}
\end{lstlisting}

\vspace{5pt}

\noindent เมื่อเรารันโปรแกรมด้านบนเราจะได้เอาต์พุตดังนี้

\vspace{5pt}

\begin{lstlisting}[style=MyC++]
Number of atoms: 7
Input Cartesian coordinates:
6       0.000000000000       0.000000000000       0.000000000000
6       0.000000000000       0.000000000000       2.845112131228
8       1.899115961744       0.000000000000       4.139062527233
1      -1.894048308506       0.000000000000       3.747688672216
1       1.942500819960       0.000000000000      -0.701145981971
1      -1.007295466862      -1.669971842687      -0.705916966833
1      -1.007295466862       1.669971842687      -0.705916966833

Torsional angles:
  3- 2- 1- 0 180.000000
  6- 5- 4- 0  36.366799  
\end{lstlisting}

\vspace{5pt}

\noindent \bful{Step 5: คำนวณจุดศูนย์กลางมวล มุมบิด (Center of Mass)}

\noindent \underline{แบบฝึกหัด}: ให้ลองเขียนโปรแกรมคำนวณจุดศูนย์กลางมวลของโมเลกุล โดยสมการที่ใช้ในการคำนวณนั้นสามารถดูได้จาก
Wikipedia ครับ

\noindent \underline{เฉลย}

\vspace{5pt}

\begin{lstlisting}[style=MyC++]
#include "molecule.h"
#include "masses.h"

#include <iostream>
#include <fstream>
#include <iomanip>
#include <cstdio>
#include <cmath>

using namespace std;

int main()
{
  Molecule mol("geom.dat", 0);

  cout << "Number of atoms: " << mol.natom << endl;
  cout << "Input Cartesian coordinates:\n";
  mol.print_geom();

  cout << "Interatomic distances (bohr):\n";
  for(int i=0; i < mol.natom; i++)
    for(int j=0; j < i; j++)
      printf("%d %d %8.5f\n", i, j, mol.bond(i,j));

  cout << "\nBond angles:\n";
  for(int i=0; i < mol.natom; i++) {
    for(int j=0; j < i; j++) {
      for(int k=0; k < j; k++) {
        if(mol.bond(i,j) < 4.0 && mol.bond(j,k) < 4.0)
          printf("%2d-%2d-%2d %10.6f\n", i, j, k, mol.angle(i,j,k)*(180.0/acos(-1.0)));
      }
    }
  }

  cout << "\nOut-of-Plane angles:\n";
  for(int i=0; i < mol.natom; i++) {
    for(int k=0; k < mol.natom; k++) {
      for(int j=0; j < mol.natom; j++) {
        for(int l=0; l < j; l++) {
          if(i!=j && i!=k && i!=l && j!=k && k!=l && mol.bond(i,k) < 4.0 && 
              mol.bond(k,j) < 4.0 && mol.bond(k,l) < 4.0)
              printf("%2d-%2d-%2d-%2d %10.6f\n", i, j, k, l, mol.oop(i,j,k,l)*(180.0/acos(-1.0)));
        }
      }
    }
  }

  cout << "\nTorsional angles:\n\n";
  for(int i=0; i < mol.natom; i++) {
    for(int j=0; j < i; j++) {
      for(int k=0; k < j; k++) {
        for(int l=0; l < k; l++) {
          if(mol.bond(i,j) < 4.0 && mol.bond(j,k) < 4.0 && mol.bond(k,l) < 4.0)
            printf("%2d-%2d-%2d-%2d %10.6f\n", i, j, k, l, mol.torsion(i,j,k,l)*(180.0/acos(-1.0)));
        }
      }
    }
  }
  
  /* find the center of mass (COM) */
  double M = 0.0;
  for(int i=0; i < mol.atom; i++) M += an2masses[(int) mol.zvals[i]];

  double xcm=0.0;
  double ycm=0.0;
  double zcm=0.0;
  double mi;
  for(int i=0; i < mol.atom; i++) {
    mi = an2masses[(int) mol.zvals[i]];
    xcm += mi * mol.geom[i][0];
    ycm += mi * mol.geom[i][1];
    zcm += mi * mol.geom[i][2];
  }
  xcm /= M;
  ycm /= M;
  zcm /= M;
  printf("\nMolecular center of mass: %12.8f %12.8f %12.8f\n", xcm, ycm, zcm);

  mol.translate(-xcm, -ycm, -zcm);

  return 0;
}
\end{lstlisting}

\vspace{5pt}

\noindent เมื่อเรารันโปรแกรมด้านบนเราจะได้เอาต์พุตดังนี้

\vspace{5pt}

\begin{lstlisting}[style=MyC++]
Number of atoms: 7
Input Cartesian coordinates:
6       0.000000000000       0.000000000000       0.000000000000
6       0.000000000000       0.000000000000       2.845112131228
8       1.899115961744       0.000000000000       4.139062527233
1      -1.894048308506       0.000000000000       3.747688672216
1       1.942500819960       0.000000000000      -0.701145981971
1      -1.007295466862      -1.669971842687      -0.705916966833
1      -1.007295466862       1.669971842687      -0.705916966833
Interatomic distances (bohr):
1 0  2.84511
2 0  4.55395
2 1  2.29803
3 0  4.19912
3 1  2.09811
3 2  3.81330
4 0  2.06517
4 1  4.04342
4 2  4.84040
4 3  5.87463
5 0  2.07407
5 1  4.05133
5 2  5.89151
5 3  4.83836
5 4  3.38971
6 0  2.07407
6 1  4.05133
6 2  5.89151
6 3  4.83836
6 4  3.38971
6 5  3.33994

Bond angles:
  0- 1- 2 124.268308
  0- 1- 3 115.479341
  0- 4- 5  35.109529
  0- 4- 6  35.109529
  0- 5- 6  36.373677
  1- 2- 3  28.377448
  4- 5- 6  60.484476

Out-of-plane angles:
  0- 3- 1- 2  -0.000000
  0- 6- 4- 5  19.939726
  0- 6- 5- 4 -19.850523
  0- 5- 6- 4  19.850523
  1- 5- 0- 4  53.678778
  1- 6- 0- 4 -53.678778
  1- 6- 0- 5  54.977064
  2- 3- 1- 0   0.000000
  3- 2- 1- 0  -0.000000
  4- 5- 0- 1 -53.651534
  4- 6- 0- 1  53.651534
  4- 6- 0- 5 -54.869992
  4- 6- 5- 0  29.885677
  4- 5- 6- 0 -29.885677
  5- 4- 0- 1  53.626323
  5- 6- 0- 1 -56.277112
  5- 6- 0- 4  56.194621
  5- 6- 4- 0 -30.558964
  5- 4- 6- 0  31.064344
  6- 4- 0- 1 -53.626323
  6- 5- 0- 1  56.277112
  6- 5- 0- 4 -56.194621
  6- 5- 4- 0  30.558964
  6- 4- 5- 0 -31.064344

Torsional angles:

  3- 2- 1- 0 180.000000
  6- 5- 4- 0  36.366799

Molecular center of mass:   0.64494926   0.00000000   2.31663792
\end{lstlisting}

%----------------------------------------
\section{เขียนโปรแกรม Hartree-Fock SCF (ภาษา Python)}
%----------------------------------------

%----------------------------------------
\subsection{ทำความเข้าใจขั้นตอน SCF กันก่อน}
%----------------------------------------

โปรแกรมเคมีควอนตัมทุกโปรแกรมจะต้องมีส่วนหนึ่งของโปรแกรมที่เป็นโค้ดสำหรับแก้สมการอันหนึ่งซึ่งขาดไม่ได้เลยนั่นก็คือ Roothaan-Hall
Equation โดยใช้วิธี Self-Consistent Field ซึ่งเป็นสมการที่เราใช้ในการคำนวณหาพลังงานของระบบที่เราสนใจ

สมการ Roothaan-Hall นั้นจะเรียกว่าเป็นสมการ HF ที่แปลงร่างมาแล้วก็ได้ สาเหตุที่เราต้องทำการแปลงร่าง HF นั้นก็เพราะว่าเราเขียน
Wavefunction ให้อยู่ในรูปที่มี Basis Function นั่นเอง (Basis Function คือสิ่งที่เราใช้อธิบายออร์บิทัลเชิงอะตอม) โดยเราจะมีสมการ
Roothaan-Hall ทั้งหมด $m$ สมการ โดยที่ $m$ คือจำนวนของ Basis Function (เรามีสมการ HF 1 สมการต่อ 1 MO และการที่เรามี
$m$ Basis Function นั้นก็จะสร้างทั้งหมด $m$ MOs ด้วย), $F$ คือ Fock Matrix ซึ่งก็จะได้จาก Density Matrix แล้ว
Density Matrix ก็คือ Matrix ที่มีสมาชิกเป็นผลคูณระหว่าง Coefficients ของ MO ซึ่งก็จะได้มาจากการประมาณค่าด้วยวิธีเริ่มต้น
(Initial Guess) แบบต่าง ๆ เช่นใช้ Huckel Method, ส่วน $S$ นั้นก็คือ Overlap Matrix ซึ่งก็จะเป็น Matrix ที่บอกว่า
Orbitals นั้นสัมพันธ์กันมากน้อยแค่ไหน, และ $\epsilon$ ของแต่ละสมการนั้นก็คือค่าพลังงานของแต่ละ MO นั้นเองซึ่งเป็นสิ่งที่เรา%
ต้องการแก้สมการหามันออกมา ทีนี้เราสามารถยุบรวมสมการ HF สำหรับแต่ละ Basis Function เข้าด้วยกันได้ ซึ่งจะได้ออกมาเป็นตามสมการที่%
สั้นและกระชับขึ้นนั่นก็คือสมการ Roothaan-Hall นั่นเอง ดังนี้ (เขียนในรูปของเมทริกซ์)

\begin{equation}
  \bm{FC} = \bm{SC \varepsilon}
\end{equation}

โดยมี $F$, $C$, และ $S$ แทน Fock Matrix, MO Coefficients Matrix, และ Overlap Matrix ตามลำดับ โดย Matrix
ทั้งสามอันนี้มีขนาดคือ $m \times m$ แล้วก็ $\epsilon$ นั้นก็มีขนาด $m \times m$ ด้วย (มีเฉพาะสมาชิกในแนวทแยงเท่านั้นที่มีค่าไม่เท่ากับ 0)
โดย $C$ มีหน้าตาดังต่อไปนี้

\begin{equation}
  \bm{C}
  =
  \left( \begin{matrix} c_{1,1} & c_{1,2} & ... & c_{1,m} \\
               c_{2,1} & c_{2,2} & ... & c_{2,m} \\
               \vdots  & \vdots  &     & \vdots  \\
               c_{m,1} & c_{m,2} & ... & c_{m,m}
    \end{matrix} \right)
\end{equation}

\noindent และ $\epsilon$

\begin{equation}
  \bm{E}
  =
  \left( \begin{matrix} \epsilon_1 & 0          & ... & 0            \\
               0          & \epsilon_2 & ... & 0            \\
               \vdots     & \vdots     &     & \vdots       \\
               0          & 0          & ... & \epsilon_{m}
    \end{matrix} \right)
\end{equation}

ซึ่งแนวคิดของการแก้ปัญหา SCF นั้นก็คือเราพยายามที่จะหาค่าของ $\bm{C}$ ที่จะทำให้มีพลังงานของระบบนั้นมีค่าน้อยที่สุดเท่าที่จะเป็นไปได้
(Energy Minimization) แต่ว่าเราดันมี $\bm{C}$ อยู่ทั้งสองข้างของสมการ ดังนั้นเราจึงต้องทำการแก้สมการด้านบนโดยการใช้การวนซ้ำ
(Iteration) จนกว่าจะได้ $\bm{C}$ ของทั้งสองข้างของสมการที่เท่ากัน (หรือเกือบจะเท่ากัน) ซึ่งจะทำให้ได้ค่าพลังงาน $\epsilon$ ที่ต่ำที่สุดด้วย

ปัญหาถัดมาก็คือว่าสมการด้านบนนั้นมันเป็น Eigenvalue Problem ในฟอร์มที่ยังแก้ไม่ได้ (แก้ได้แต่ว่าจะได้คำตอบที่ไม่ถูกต้อง) ซึ่งถ้าหากเราสามารถ%
เปลี่ยนจาก $\bm{FC} = \bm{SC \epsilon}$ ให้เป็น $\bm{FC} = \bm{C \epsilon}$ ได้ ก็จะทำให้เราสามารถแก้ Eigenvalue Problem
ได้อย่างมีประสิทธิภาพและได้คำตอบที่ถูกต้อง ดังนั้นเราจึงมีเทคนิคในการแปลงโดยการทำ Orthogonalization ซึ่งถ้าสรุปสั้น ๆ ก็คือว่าเราสามารถ%
แปลงออกมาได้เป็น

\begin{equation}
  \bm{F'C'} = \bm{C'E}
\end{equation}

\noindent โดยที่

\begin{gather}
  \bm{F'} = \bm{S}^{-1/2}\bm{F}\bm{S}^{-1/2} \\
  \bm{C'} = \bm{S}^{-1/2}\boldsymbol{C}
\end{gather}

\noindent ตามวิชา Linear Algebra ถ้าเราต้องการหา Matrix ของ $\epsilon$ เราสามารถใช้วิธี Diagonalization
กับสมการ Roothaan-Hall ได้เพราะว่าสมการนี้มันเป็น Eigenfunction ซึ่งกระบวนการที่จะใช้ในการแก้นั้นก็คือตามขั้นตอนต่อไปนี้

\noindent \textbf{กระบวนการ SCF แบบคร่าว ๆ ตามทฤษฎี}

\begin{enumerate}[topsep=0pt,noitemsep]
  \setlength\itemsep{1em}
  \item เรากำหนดตำแหน่งของอะตอมในโมเลกุล, ประจุ, และทำการเลือก Basis Set

  \item เริ่มคำนวณพลังงานจลน์และพลังงานศักย์ รวมไปถึง Overlap Integral

  \item คำนวณ Orthogonalizing Matrix โดยใช้ Overlap Matrix (Overlap Matrix ที่ถูกสร้างมาจาก Overlap Integral
        ที่ได้จากขั้นที่ 2 อีกที)

  \item คำนวณ Fock Matrix อันแรกเลยโดยใช้พลังงานจลน์และพลังงานศักย์แล้วก็ใช้ Initial Guess ที่ได้จาก Coefficients
        ของ Basis Set ที่กำหนดไว้ตั้งแต่ขั้นตอนที่ 1

  \item ใช้ Orthogonalizing Matrix เพื่อแปลง (Tranform) Fock Matrix ให้เป็น Matrix อันใหม่ (เรียกว่าเป็น $F'$ ก็แล้วกัน)
        ที่มันขึ้นอยู่กับ Orthogonal Set ของฟังก์ชันที่ได้มาจาก Basis Set ที่ถูกเซนเตอร์กับอะตอม (Atom-centered Basis Set)

  \item ทำการทำเมทริกซ์แนวทแยง (Diagonalize) Fock Matrix เพื่อหา Coefficient Matrix ที่ถูกแปลงมาแล้ว (เรียกว่า $C'$)
        ก็ได้แล้วก็หาพลังงานของแต่ละ MO ได้

  \item เปรียบเทียบ $C'$ และพลังงานกับค่าที่ได้จากรอบก่อนหน้านี้ ถ้าผลต่างยังไม่น้อยกว่า Cutoff ที่กำหนดไว้ก็ให้นำ Fock Matrix
        ที่ได้มาล่าสุดไปใช้ใหม่อีกครั้งหนึ่งในขั้นที่ 4 ทำวนไปเรื่อย ๆ จนได้คำตอบที่แม่นยำ
\end{enumerate}

สำหรับการกำหนด Basis Set นั้นก็คือการเลือกชุดค่าสัมประสิทธิ์ของออร์บิทัล (Wavefunction) ของธาตุแต่ละธาตุ จริง ๆ แล้ว Basis Set
นั้นก็คือไฟล์ Text ที่มีรูปแบบ (Format) ที่แตกต่างกันไปตามโปรแกรมที่ใช้ เราสามารถดาวน์โหลดไฟล์ Basis Set ได้ที่เว็บไซต์
\url{https://www.basissetexchange.org/} ตัวอย่างเช่น Basis Set: aug-cc-PV7Z ของอะตอมคาร์บอน
\url{https://www.basissetexchange.org/basis/aug-cc-pv7z/format/nwchem/?version=0&elements=6}

%----------------------------------------
\subsection{มาเขียนโปรแกรมคำนวณ SCF กันเถอะ}
%----------------------------------------

ในส่วนนี้ผู้อ่านจะได้ศึกษาการเขียนโปรแกรมคำนวณ SCF ด้วยภาษา Python ซึ่งโปรแกรมด้านล่างนี้เป็นโปรแกรมที่ดัดแปลงมาจากโปรแกรมคำนวณ
SCF จากหนังสือ Modern Quantum Chemsitry: Introduction to Advanced Electronic Structure Theory เขียนโดย Attila Szabo
และ Neil S. Ostlund ซึ่งเป็นโปรแกรมที่คำนวณพลังงานของโมเลกุล \ce{HeH^{+}} ซึ่งมี Electronic Configuration ที่เหมือนกันกับ
\ce{H2} แต่จะมีความแตกต่างกันตรงที่ \ce{HeH^{+}} นั้นมีประจุ +2 อยู่ที่อะตอม \ce{He} ทำให้โมเลกุลนี้ไม่มีความสมมาตร จึงต้องทำการ%
คำนวณด้วยวิธีการวนซ้ำ


\noindent \bful{Step 1: สร้างออร์บิทัล}

ขั้นตอนแรกสุดเลยในการเขียนโปรแกรม SCF ก็คือการสร้างออร์บิทัล ทำไมเราต้องสร้างออร์บิทัลก่อนล่ะ? ก็เพราะว่าเราออร์บิทัลนั้นจริง ๆ แล้วก็คือ
\enquote{ฟังก์ชันคลื่นของอิเล็กตรอน 1 ตัว} นั่นเอง ซึ่งเราจะกำหนดให้มีเซทของออร์บิทัล 1 เซทที่ใช้ในการอธิบายโมเลกุลทั้งโมเลกุล โดยเราจะใช้
Atomic Orbitals ที่มีจุดศูนย์กลางอยู่ที่อะตอม และเรานำ Atomic Orbitals แต่ละอันมารวมกันให้เป็นฟังก์ชันคลื่นหรือ Delocalized Orbital
ได้โดยการใช้ Linear Combination of Atomic Orbitals (LCAO) ดังนี้

\begin{equation}
  \psi_i(\boldsymbol{r}_i)
  =
  \sum^{K}_{\mu} c_{\mu} \phi_{\mu I}(\boldsymbol{r}_i)
\end{equation}

\noindent โดยที่ $K$ คือจำนวน Basis Functions, $i = 1, 2, \dots, K$, และ $c$ คือพารามิเตอร์ที่เราจะต้องทำการปรับเพื่อลดค่า%
พลังงานของระบบโมเลกุล

เนื่องจากว่าวิธีการ Hartree-Fock นั้นใช้หลักการ Variation ซึ่งเป็นการหาฟังก์ชันคลื่นของระบบที่มีค่าพลังงานที่ไม่ว่ายังไงก็จะต้องมีค่าสูงกว่า%
พลังงานจริงของระบบ ข้อดีของ Variational Method ก็คือเราสามารถปรับพารามิเตอร์อะไรก็ได้อย่างเป็นระบบเพื่อให้ได้ฟังก์ชันคลื่นที่มีความถูกต้อง%
มากขึ้นและให้ค่าพลังงานที่ลู่เข้าหรือ Converged

สำหรับ Atomic Orbitals ที่เราจะใช้นั้นมีชื่อเรียกว่า Slater Type Orbitals (STO) สำหรับออร์บิทัล $1s$ นั้นมีสมการดังต่อไปนี้

\begin{equation}
  \phi^{Slater}\left( \boldsymbol{r}\right)
  =
  \left( \zeta^3/\pi \right)^{1/2}e^{-\zeta \boldsymbol{r}}
\end{equation}

\noindent เราลองมาพลอต STO อันนี้กันเพื่อดูว่ามีหน้าตาเป็นยังไง เริ่มต้นโดยการอิมพอร์ตไลบารี่ที่เราต้องการก่อน

\vspace{5pt}

\begin{lstlisting}[style=MyPython]
%matplotlib inline
import math
import numpy as np
import scipy.special as sp
import matplotlib.pyplot as plt
\end{lstlisting}

\vspace{5pt}

\noindent สร้างฟังก์ชันสำหรับพลอต STO

\vspace{5pt}

\begin{lstlisting}[style=MyPython]
x = np.linspace(-5,5,num=1000)
r = abs(x)
zeta = 1.0
psi_STO = (zeta**3/np.pi)**(0.5)*np.exp(-zeta*r)

plt.figure(figsize=(4,3))
plt.plot(x,psi_STO)
\end{lstlisting}

\vspace{5pt}

Slater Type Orbitals (STO) นั้นจริง ๆ แล้วก็คือฟังก์ชันที่เป็นผลเฉลยของสมการชโรดิงเงอร์สำหรับไฮโดรเจนอะตอมนั่นเอง (อิเล็กตรอน 1 ตัว)
แต่ว่าการคำนวณอินทิกรัลของ STO นั้นสิ้นเปลืองมาก วิธีหนึ่งที่เราใช้ในการประมาณฟังก์ชัน STO นั้นก็คือการใช้ผลรวมของ Contracted Gaussian
Functions (CGF) ซึ่งการที่เราใช้ CGF แทนนั้นช่วยทำให้เราประหยัดเวลาในการคำนวณมากขึ้นเพราะว่าการคำนวณอินทิกรัลของผลคูณระหว่าง
Gaussian Functions 2 อันนั้นค่อนข้างง่ายพอสมควร สมการต่อไปนี้คือ Gaussian Function (CGF) ของออร์บิทัล $1s$

\begin{equation}
  \phi^{GF}(\alpha)
  =
  (2\alpha/\pi)^{3/4}exp(-\alpha r^{2})
\end{equation}

\noindent และผลรวมของ CGF คือ

\begin{equation}
  \phi^{CGF}\left( \boldsymbol{r}\right)
  =
  \sum_n d_n\phi^{GF}_n(\alpha)
\end{equation}

\noindent ซึ่งเราใช้ Gaussian Functions 3 อันในการหา Approximation ของ STO นั่นเอง ดังนี้

\begin{equation}
  \phi^{CGF}_{STO-3G}\left( \boldsymbol{r}\right)
  =
  \sum^3_n d_n\phi^{GF}_n(\alpha)
\end{equation}

\vspace{5pt}

\begin{lstlisting}[style=MyPython]
# Coeff is the d_n variable in the equation above
Coeff = np.array(
    [[1.00000, 0.0000000, 0.000000], [0.678914, 0.430129, 0.000000], [0.444635, 0.535328, 0.154329]]
)

# Expon is the alpha variable in the equation above
Expon = np.array(
    [[0.270950, 0.000000, 0.000000], [0.151623, 0.851819, 0.000000], [0.109818, 0.405771, 2.227660]]
)

psi_CGF_STO1G = Coeff[0, 0] * (2 * Expon[0, 0] / np.pi) ** (0.75) * np.exp(-Expon[0, 0] * r**2)
psi_CGF_STO2G = (
    Coeff[1, 0] * (2 * Expon[1, 0] / np.pi) ** (0.75) * np.exp(-Expon[1, 0] * r**2)
    + Coeff[1, 1] * (2 * Expon[1, 1] / np.pi) ** (0.75) * np.exp(-Expon[1, 1] * r**2)
    + Coeff[1, 2] * (2 * Expon[1, 2] / np.pi) ** (0.75) * np.exp(-Expon[1, 2] * r**2)
)
psi_CGF_STO3G = (
    Coeff[2, 0] * (2 * Expon[2, 0] / np.pi) ** (0.75) * np.exp(-Expon[2, 0] * r**2)
    + Coeff[2, 1] * (2 * Expon[2, 1] / np.pi) ** (0.75) * np.exp(-Expon[2, 1] * r**2)
    + Coeff[2, 2] * (2 * Expon[2, 2] / np.pi) ** (0.75) * np.exp(-Expon[2, 2] * r**2)
)

# Plot the three functions
plt.figure(figsize=(5, 3))
plt.title("Approximations to a STO with CGF")
plt.plot(x, psi_STO, label="STO")
plt.plot(x, psi_CGF_STO1G, label="STO-1G")
plt.legend()
plt.figure(figsize=(5, 3))
plt.plot(x, psi_STO, label="STO")
plt.plot(x, psi_CGF_STO2G, label="STO-2G")
plt.legend()
plt.figure(figsize=(5, 3))
plt.plot(x, psi_STO, label="STO")
plt.plot(x, psi_CGF_STO3G, label="STO-3G")
plt.legend()
\end{lstlisting}

\vspace{5pt}

จะเห็นได้ว่ายิ่งจำนวนของ GF เพิ่มมากขึ้นเท่าไหร่ ฟังก์ชันนั้นก็จะมีความเข้าใกล้ความเป็น STO มากขึ้นเท่านั้น โดยตำแหน่งที่ $x = 0$ นั้นจะเห็นว่า%
เป็นตำแหน่งที่ Approximation นั้นแย่ที่สุด โดยเราจะเรียกบริเวณที่เป็นความคลาดเคลื่อนของ CGF จาก STO นี้ว่า Cusp

\noindent \bful{Step 2: เตรียมส่วนผสมสำหรับการคำนวณ SCF}

\noindent $\bullet$ Step 2.1: กำหนดตัวแปรที่จะใช้ในการเก็บข้อมูลทางควอนตัมของโมเลกุล

\vspace{5pt}

\begin{lstlisting}[style=MyPython]
# Make all variables 'global variables' accessible through out the whole program
global H, S, X, XT, TT, G, C, P, Oldp, F, Fprime, Cprime, E

H = np.zeros([2, 2])
S = np.zeros([2, 2])
X = np.zeros([2, 2])
XT = np.zeros([2, 2])
TT = np.zeros([2, 2, 2, 2])
G = np.zeros([2, 2])
C = np.zeros([2, 2])

P = np.zeros([2, 2])
Oldp = np.zeros([2, 2])
F = np.zeros([2, 2])
Fprime = np.zeros([2, 2])
Cprime = np.zeros([2, 2])
E = np.zeros([2, 2])

Energy = 0.0
Delta = 0.0

# Values below taken from 'Modern Quantum Chemistry' book
# Appendix B: Two-Electron Self-Consistent-Field Program
IOP = 2
N = 3
R = 1.4632
Zeta1 = 2.0925
Zeta2 = 1.24
Za = 2.0
Zb = 1.0
\end{lstlisting}

\vspace{5pt}

\noindent $\bullet$ Step 2.2: สร้างฟังก์ชันสำหรับคำนวณ Integrals ต่าง ๆ

การคำนวณ Integrals นั้นจะทำได้ง่ายขึ้นเยอะมาก ๆ เลยถ้าหากว่าเราใช้ฟังก์ชัน Gaussian ในการอธิบายออร์บิทัล ผมแนะนำให้ผู้อ่านศึกษา 
Appendix ของหนังสือ Modern Quantum Chemistry ครับซึ่งจะช่วยให้เข้าใจได้มากขึ้น

\vspace{5pt}

\begin{lstlisting}[style=MyPython]
def F0(t):
  """
  F function for 1s orbital
  """
  if t < 1e-6:
      return 1.0 - t / 3.0
  else:
      return 0.5 * (np.pi / t) ** 0.5 * sp.erf(t**0.5)
\end{lstlisting}

\vspace{5pt}

\noindent ฟังก์ชันสำหรับคำนวณ Overlap Matrix

\vspace{5pt}

\begin{lstlisting}[style=MyPython]
def S_int(A, B, Rab2):
  """
  Calculates the overlap between two gaussian functions
  """
  return (np.pi / (A + B)) ** 1.5 * np.exp(-A * B * Rab2 / (A + B))
\end{lstlisting}

\vspace{5pt}

\noindent ฟังก์ชันสำหรับคำนวณ Kinetic Energy Integrals

\vspace{5pt}

\begin{lstlisting}[style=MyPython]
def T_int(A, B, Rab2):
  """
  Calculates the kinetic energy integrals for un-normalised primitives
  """
  return (
      A
      * B
      / (A + B)
      * (3.0 - 2.0 * A * B * Rab2 / (A + B))
      * (np.pi / (A + B)) ** 1.5
      * np.exp(-A * B * Rab2 / (A + B))
  )
\end{lstlisting}

\vspace{5pt}

\noindent ฟังก์ชันสำหรับคำนวณ Nuclear Attraction Integrals

\vspace{5pt}

\begin{lstlisting}[style=MyPython]
def V_int(A, B, Rab2, Rcp2, Zc):
  """
  Calculates the un-normalised nuclear attraction integrals
  """
  V = 2.0 * np.pi / (A + B) * F0((A + B) * Rcp2) * np.exp(-A * B * Rab2 / (A + B))

  return -V * Zc
\end{lstlisting}

\vspace{5pt}

\noindent ฟังก์ชันสำหรับคำนวณความคลาดเคลื่อน

\vspace{5pt}

\begin{lstlisting}[style=MyPython]
def erf(t):
  """
  Approximation for the error function
  """
  P = 0.3275911
  A = [0.254829592, -0.284496736, 1.421413741, -1.453152027, 1.061405429]
  T = 1.0 / (1 + P * t)
  Tn = T
  Poly = A[0] * Tn

  for i in range(1, 5):
      Tn = Tn * T
      Poly = Poly * A[i] * Tn

  return 1.0 - Poly * np.exp(-t * t)
\end{lstlisting}

\vspace{5pt}

\noindent ฟังก์ชันสำหรับคำนวณ Two-Electron Integrals
\vspace{5pt}

\begin{lstlisting}[style=MyPython]
def TwoE(A, B, C, D, Rab2, Rcd2, Rpq2):
  """
  Calculate two-electron integrals
  A, B, C, D are the exponents alpha, beta, etc.
  Rab2 equals squared distance between center A and center B
  """
  return (
      2.0
      * (np.pi**2.5)
      / ((A + B) * (C + D) * np.sqrt(A + B + C + D))
      * F0((A + B) * (C + D) * Rpq2 / (A + B + C + D))
      * np.exp(-A * B * Rab2 / (A + B) - C * D * Rcd2 / (C + D))
  )
\end{lstlisting}

\vspace{5pt}

\noindent สร้างฟังก์ชันสำหรับเรียกใช้ฟังก์ชันด้านบนที่เราได้เขียนไว้ ประกาศตัวแปรทั้งหมดที่ต้องใช้และทำการรวม Integrals ทั้งหมด
(เราจะเรียกใช้ฟังก์ชันนี้ภายหลัง)

\vspace{5pt}

\begin{lstlisting}[style=MyPython]
def Intgrl(N, R, Zeta1, Zeta2, Za, Zb):
  """
  Declares the variables and compiles the integrals
  """

  global S12, T11, T12, T22, V11A, V12A, V22A, V11B, V12B, V22B, V1111, V2111, V2121, V2211, V2221, V2222

  S12 = 0.0
  T11 = 0.0
  T12 = 0.0
  T22 = 0.0
  V11A = 0.0
  V12A = 0.0
  V22A = 0.0
  V11B = 0.0
  V12B = 0.0
  V22B = 0.0
  V1111 = 0.0
  V2111 = 0.0
  V2121 = 0.0
  V2211 = 0.0
  V2221 = 0.0
  V2222 = 0.0

  R2 = R * R

  # The coefficients for the contracted Gaussian functions are below
  Coeff = np.array(
      [[1.00000, 0.0000000, 0.000000], [0.678914, 0.430129, 0.000000], [0.444635, 0.535328, 0.154329]]
  )

  Expon = np.array(
      [[0.270950, 0.000000, 0.000000], [0.151623, 0.851819, 0.000000], [0.109818, 0.405771, 2.227660]]
  )
  D1 = np.zeros([3])
  A1 = np.zeros([3])
  D2 = np.zeros([3])
  A2 = np.zeros([3])

  # This loop constructs the contracted Gaussian functions
  for i in range(N):
      A1[i] = Expon[N - 1, i] * (Zeta1**2)
      D1[i] = Coeff[N - 1, i] * ((2.0 * A1[i] / np.pi) ** 0.75)
      A2[i] = Expon[N - 1, i] * (Zeta2**2)
      D2[i] = Coeff[N - 1, i] * ((2.0 * A2[i] / np.pi) ** 0.75)

  # Calculate one electron integrals
  # Centre A is first atom centre B is second atom
  # Origin is on second atom
  # V12A - off diagonal nuclear attraction to centre A etc.
  for i in range(N):
      for j in range(N):
          # Rap2 - squared distance between centre A and centre P
          Rap = A2[j] * R / (A1[i] + A2[j])
          Rap2 = Rap**2
          Rbp2 = (R - Rap) ** 2
          S12 = S12 + S_int(A1[i], A2[j], R2) * D1[i] * D2[j]
          T11 = T11 + T_int(A1[i], A1[j], 0.0) * D1[i] * D1[j]
          T12 = T12 + T_int(A1[i], A2[j], R2) * D1[i] * D2[j]
          T22 = T22 + T_int(A2[i], A2[j], 0.0) * D2[i] * D2[j]
          V11A = V11A + V_int(A1[i], A1[j], 0.0, 0.0, Za) * D1[i] * D1[j]
          V12A = V12A + V_int(A1[i], A2[j], R2, Rap2, Za) * D1[i] * D2[j]
          V22A = V22A + V_int(A2[i], A2[j], 0.0, R2, Za) * D2[i] * D2[j]
          V11B = V11B + V_int(A1[i], A1[j], 0.0, R2, Zb) * D1[i] * D1[j]
          V12B = V12B + V_int(A1[i], A2[j], R2, Rbp2, Zb) * D1[i] * D2[j]
          V22B = V22B + V_int(A2[i], A2[j], 0.0, 0.0, Zb) * D2[i] * D2[j]

  # Calculate two electron integrals

  for i in range(N):
      for j in range(N):
          for k in range(N):
              for l in range(N):
                  Rap = A2[i] * R / (A2[i] + A1[j])
                  Rbp = R - Rap
                  Raq = A2[k] * R / (A2[k] + A1[l])
                  Rbq = R - Raq
                  Rpq = Rap - Raq
                  Rap2 = Rap * Rap
                  Rbp2 = Rbp * Rbp
                  Raq2 = Raq * Raq
                  Rbq2 = Rbq * Rbq
                  Rpq2 = Rpq * Rpq
                  V1111 = (
                      V1111
                      + TwoE(A1[i], A1[j], A1[k], A1[l], 0.0, 0.0, 0.0) * D1[i] * D1[j] * D1[k] * D1[l]
                  )
                  V2111 = (
                      V2111
                      + TwoE(A2[i], A1[j], A1[k], A1[l], R2, 0.0, Rap2) * D2[i] * D1[j] * D1[k] * D1[l]
                  )
                  V2121 = (
                      V2121 + TwoE(A2[i], A1[j], A2[k], A1[l], R2, R2, Rpq2) * D2[i] * D1[j] * D2[k] * D1[l]
                  )
                  V2211 = (
                      V2211 + TwoE(A2[i], A2[j], A1[k], A1[l], 0.0, 0.0, R2) * D2[i] * D2[j] * D1[k] * D1[l]
                  )
                  V2221 = (
                      V2221
                      + TwoE(A2[i], A2[j], A2[k], A1[l], 0.0, R2, Rbq2) * D2[i] * D2[j] * D2[k] * D1[l]
                  )
                  V2222 = (
                      V2222
                      + TwoE(A2[i], A2[j], A2[k], A2[l], 0.0, 0.0, 0.0) * D2[i] * D2[j] * D2[k] * D2[l]
                  )
  return
\end{lstlisting}

\vspace{5pt}

\noindent สร้างฟังก์ชันสำหรับนำ Integrals ที่คำนวณได้ใส่เข้าไปใน Array (เราจะเรียกใช้ฟังก์ชันนี้ภายหลัง)

\vspace{5pt}

\begin{lstlisting}[style=MyPython]
def Collect():
  """
  Takes the basic integrals and assembles the relevant matrices,
  that are S, H, X, XT and two electron integrals
  """
  # Form core hamiltonian
  H[0, 0] = T11 + V11A + V11B
  H[0, 1] = T12 + V12A + V12B
  H[1, 0] = H[0, 1]
  H[1, 1] = T22 + V22A + V22B

  # Form overlap matrix
  S[0, 0] = 1.0
  S[0, 1] = S12
  S[1, 0] = S12
  S[1, 1] = 1.0

  # This is S^-1/2
  X[0, 0] = 1.0 / np.sqrt(2.0 * (1.0 + S12))
  X[1, 0] = X[0, 0]
  X[0, 1] = 1.0 / np.sqrt(2.0 * (1.0 - S12))
  X[1, 1] = -X[0, 1]

  # This is the coulomb and exchange term (aa|bb) and (ab|ba)
  TT[0, 0, 0, 0] = V1111
  TT[1, 0, 0, 0] = V2111
  TT[0, 1, 0, 0] = V2111
  TT[0, 0, 1, 0] = V2111
  TT[0, 0, 0, 1] = V2111
  TT[1, 0, 1, 0] = V2121
  TT[0, 1, 1, 0] = V2121
  TT[1, 0, 0, 1] = V2121
  TT[0, 1, 0, 1] = V2121
  TT[1, 1, 0, 0] = V2211
  TT[0, 0, 1, 1] = V2211
  TT[1, 1, 1, 0] = V2221
  TT[1, 1, 0, 1] = V2221
  TT[1, 0, 1, 1] = V2221
  TT[0, 1, 1, 1] = V2221
  TT[1, 1, 1, 1] = V2222
\end{lstlisting}

\vspace{5pt}

\noindent \bful{Step 3: สร้างตัวคำนวณ SCF Calculator}

\vspace{5pt}

\noindent สร้างฟังก์ชันสำหรับการทำ Diagonalization ของ Fock Matrix ซึ่งเราจะได้ Eigenvectors และ Eigenvalues ออกมา
ซึ่งก็คือ Array C กับ Array E ตามลำดับ

\vspace{5pt}

\begin{lstlisting}[style=MyPython]
def Diag(Fprime, Cprime, E):
  """
  Diagonalises F to give eigenvectors in C and eigenvalues in E
  theta is the angle describing the solution
  """
  # Angle for heteronuclear diatonic
  Theta = 0.5 * math.atan(2.0 * Fprime[0, 1] / (Fprime[0, 0] - Fprime[1, 1]))
  # print('Theta', Theta)

  Cprime[0, 0] = np.cos(Theta)
  Cprime[1, 0] = np.sin(Theta)
  Cprime[0, 1] = np.sin(Theta)
  Cprime[1, 1] = -np.cos(Theta)

  E[0, 0] = (
      Fprime[0, 0] * np.cos(Theta) ** 2
      + Fprime[1, 1] * np.sin(Theta) ** 2
      + Fprime[0, 1] * np.sin(2.0 * Theta)
  )
  E[1, 1] = (
      Fprime[1, 1] * np.cos(Theta) ** 2
      + Fprime[0, 0] * np.sin(Theta) ** 2
      - Fprime[0, 1] * np.sin(2.0 * Theta)
  )

  if E[1, 1] <= E[0, 0]:
      Temp = E[1, 1]
      E[1, 1] = E[0, 0]
      E[0, 0] = Temp
      Temp = Cprime[0, 1]
      Cprime[0, 1] = Cprime[0, 0]
      Cprime[0, 0] = Temp
      Temp = Cprime[1, 1]
      Cprime[1, 1] = Cprime[1, 0]
      Cprime[1, 0] = Temp
  return
\end{lstlisting}

\vspace{5pt}

\noindent ฟังก์ชันสุดท้ายคือฟังก์ชันที่จะเป็นการรันการคำนวณ SCF

\vspace{5pt}

\begin{lstlisting}[style=MyPython]
def SCF(R, Za, Zb, G):
  """
  Performs the SCF iterations
  """
  Crit = 1e-11  # Convergence critera
  Maxit = 250  # Maximum number of iterations
  Iter = 0

  #--------
  # STEP 1. Guess an initial density matrix
  #--------
  # Use core hamiltonian for initial guess of F (P = 0)
  P = np.zeros([2, 2])

  Energy = 0.0

  while Iter < Maxit:
      Iter += 1

      #--------
      # STEP 2. Calculate the Fock matrix 
      #--------
      # Form two electron part of Fock matrix from P
      # This is the two electron contribution in the equations above
      G = np.zeros([2, 2])  
      for i in range(2):
          for j in range(2):
              for k in range(2):
                  for l in range(2):
                      G[i, j] = G[i, j] + P[k, l] * (TT[i, j, k, l] - 0.5 * TT[i, l, k, j])

      # Add core hamiltonian H^CORE to get Fock matrix
      F = H + G

      # Calculate the electronic energy
      Energy = np.sum(0.5 * P * (H + F))

      #--------
      # STEP 3. Calculate F' 
      # (remember S^-1/2 is X and S^1/2 is X.T) 
      #--------
      G = np.matmul(F, X)
      Fprime = np.matmul(X.T, G)

      #--------
      # STEP 4. Solve the eigenvalue problem 
      #--------
      # Diagonalise transformed Fock matrix
      Diag(Fprime, Cprime, E)

      #--------
      # STEP 5. Calculate the molecular orbitals coefficients 
      #--------
      # Transform eigen vectors to get matrix C
      C = np.matmul(X, Cprime)

      # STEP 6. Calculate the new density matrix from the old P 
      Oldp = np.array(P)
      P = np.zeros([2, 2])

      # Form new density matrix
      for i in range(2):
          for j in range(2):
              # Save present density matrix before creating a new one
              for k in range(1):
                  P[i, j] += 2.0 * C[i, k] * C[j, k]

      #--------
      # STEP 7. Check to see if the energy has converged 
      #--------
      Delta = 0.0
      # Calculate delta the difference between the old and 
      # new density matrix (Old P and new P)
      Delta = P - Oldp
      Delta = np.sqrt(np.sum(Delta**2) / 4.0)

      print("Step ", Iter, " Elec Energy", Energy, " Diff", Delta)

      # Check for convergence
      if Delta < Crit:
          # Add nuclear repulsion to get the total energy
          Energy_tot = Energy + Za * Zb / R
          print("")
          print("Calculation converged with electronic energy:", Energy)
          print("Calculation converged with total energy:", Energy_tot)
          print("Density matrix")
          print(P)
          print("Mulliken populations")
          print(np.matmul(P, S))
          print("Coeffients")
          print(C)

          break
\end{lstlisting}

\vspace{5pt}

\noindent \bful{Step 4: รันการคำนวณ SCF และตรวจสอบความถูกต้อง}

\vspace{5pt}

\noindent และแล้วเราก็มาถึงขั้นตอนสุดท้ายนั่นก็คือการรันการคำนวณ SCF โดยสรุปอีกครั้งหนึ่งว่าขั้นตอนการคำนวณนั้นมีอังกอริทึมดังต่อไปนี้

\begin{enumerate}[topsep=0pt,noitemsep]
  \setlength\itemsep{1em}
  \item ทำการเดา Initial Density Matrix $\bm{P}$ โดยในตัวอย่างโค้ดของเรานั้นจะใช้ $\bm{P} = 0$ เพื่อความง่าย

  \item นำ $\bm{P}$ มาสร้าง Fock Matrix $\bm{F}$

  \item คำนวณ $\bm{F'} = \bm{S}^{-1/2}\bm{F}\bm{S}^{1/2}$

  \item แก้สมการ Eigenvalue Problem โดยการนำ Secular Equation $|\bm{F'} - \bm{E}\bm{I}| = 0$ มาทำ Diagonalization
        ซึ่งเราจะได้ $\bm{E}$ และ $\bm{C}$ ออกมา

  \item คำนวณ Density Matrix $\bm{P}$ อันใหม่จาก $\bm{C}$

  \item ตรวจสอบเงื่อนไขว่าพลังงานนั้น Converged แล้วหรือยัง ถ้าหากว่ายังไม่ Converged ให้วนซ้ำขั้นตอนด้านบน
\end{enumerate}

เราเริ่มด้วยการเรียกใช้ฟังก์ชัน \pyinline{Intgrl} เพื่อคำนวณ One-Electron Intregral และ One-Electron Integral และตามด้วยฟังก์ชัน
\pyinline{Collect} และฟังก์ชัน \pyinline{SCF} ตามลำดับ

\vspace{5pt}

\begin{lstlisting}[style=MyPython]
# Calculate one and two electron integrals
Intgrl(N, R, Zeta1, Zeta2, Za, Zb)

# Put all integals into array
Collect()

# Perform the SCF calculation
SCF(R, Za, Zb, G)
\end{lstlisting}

\vspace{5pt}

เมื่อรันแล้วจะได้เอาต์พุตของการคำนวณ SCF ของระบบโมเลกุล \ce{HeH^{+}} ดังนี้

\vspace{5pt}

\begin{lstlisting}[style=MyPython]
Step  1  Elec Energy 0.0  Diff 0.8828668530136917
Step  2  Elec Energy -4.141862876133925  Diff 0.2791763040686421
Step  3  Elec Energy -4.22649189912899  Diff 0.029661780077229444
Step  4  Elec Energy -4.227522925343759  Diff 0.0023182848695558057
Step  5  Elec Energy -4.227529268100319  Diff 0.00017439769686161983
Step  6  Elec Energy -4.227529304014095  Diff 1.3079512369092073e-05
Step  7  Elec Energy -4.227529304216109  Diff 9.807146593527476e-07
Step  8  Elec Energy -4.227529304217244  Diff 7.353368030466615e-08
Step  9  Elec Energy -4.22752930421725  Diff 5.5135252472270695e-09
Step  10  Elec Energy -4.227529304217251  Diff 4.1340208808251866e-10
Step  11  Elec Energy -4.227529304217252  Diff 3.099665019964731e-11
Step  12  Elec Energy -4.227529304217252  Diff 2.3244357915420586e-12

Calculation converged with electronic energy: -4.227529304217252
Calculation converged with total energy: -2.86066216370331
Density matrix
[[1.28614168 0.54017322]
  [0.54017322 0.22687011]]
Mulliken populations
[[1.52963579 1.11992783]
  [0.64243955 0.47036421]]
Coeffients
[[ 0.80191698 -0.78226577]
  [ 0.33680121  1.06844537]]
\end{lstlisting}

\vspace{5pt}

จากผลการคำนวณด้านบนจะเห็นได้ว่าพลังงานของโมเลกุล \ce{HeH^{+}} ที่คำนวณออกมาได้นั้นมีค่าลดลงเรื่อย ๆ โดยผ่านการคำนวณ SCF ทั้งหมด
12 ครั้ง พลังงานรวมของโมเลกุลที่คำนวณได้คือ -2.86066216370331 Hartree

\noindent แหล่งความรู้สำหรับอ่านเพิ่มเติม

\begin{enumerate}[topsep=0pt,noitemsep]
  \setlength\itemsep{1em}
  \item ถ้าอยากศึกษาทฤษฎี Hartree-Fock รวมถึง Variational Principle และ Basis Sets ผมแนะนำให้อ่านเลคเชอร์โน๊ตของคอร์ส
        Advanced Computational Chemistry\footnote{\url{http://www.chem.helsinki.fi/~manninen/lecture_notes.pdf}}

  \item ถ้าอยากศึกษาการพิสูจน์ทฤษฎี Hartree-Fock แบบละเอียด ผมแนะนำให้อ่าน \enquote{Derivation of Hartree-Fock Theory}
        โดย Arvi Rauk\footnote{\url{https://onlinelibrary.wiley.com/doi/10.1002/0471220418.app0a}}

  \item ถ้าอยากศึกษาการคำนวณ Molecular Integrals แบบละเอียด ผมแนะนำให้อ่าน \enquote{Fundamentals of Molecular
          Integrals Evaluation} โดย Justin T. Fermann และ Edward F. Valeev
\end{enumerate}

%----------------------------------------
\section{เขียนโปรแกรมคำนวณ M\o{}ller-Plesset Perturbation (ภาษา Python)}
%----------------------------------------

ถ้าหากว่าเราสามารถเขียนโปรแกรมสำหรับคำนวณ Hartree-Fock ได้แล้ว การเขียนโปรแกรมคำนวณ M\o{}ller-Plesset นั้นก็ทำได้ไม่ยาก 
เพราะว่าเรามี Transformed Two-Electron Integrals อยู่แล้ว เราก็สามารถนำมาใช้งานต่อได้เลย โดยเฉพาะการคำนวณ M\o{}ller-Plesset 
แบบ Second Order Perturbation หรือเรียกสั้น ๆ ว่า MP2 ยิ่งง่ายเข้าไปใหญ่ เพราะว่าเราไม่ต้องใช้วิธีการวนซ้ำแบบที่เราทำใน Hartree-Fock 
โดยพลังงานที่เราจะคำนวณด้วย MP2 นั้นก็คือ Correlation Energy ซึ่งเป็นพลังงานที่เกิดการที่อิเล็กตรอนในโมเลกุลนั้นพยายามผลักหรือหลีกเลี่ยง%
ออกจากกัน (Avoid) โดยพลังงานงานของ MP2 สามารถเขียนออกมาได้ในรูปของ Spin Orbital Basis ดังนี้

\begin{equation}
  E_{\rm MP2}
  =
  \frac{1}{4}
  \sum_{ijab}
  \frac{
    \vert \langle ij \vert \vert ab \rangle\vert ^2
  }{
    \epsilon_i+\epsilon_j-\epsilon_a-\epsilon_b
  }
\end{equation}

\noindent โดยที่ $i$ กับ $j$ คือดัชนีที่บอกหมายเลขของออร์บิทัลที่มีอิเล็กตรอนบรรจุอยู่ (Occupied Orbitals) และ $a$ กับ $b$ 
คือดัชนีที่บอกหมายเลขของออร์บิทัลที่ไม่มีอิเล็กตรอน (Unoccupied Orbitals หรือ Virtual Orbitals) ส่วนเทอม Integrals 
ที่อยู่ด้านบนของของเศษส่วนนั้นก็คือ Double-Bar Integrals ซึ่งเป็นเทอมที่อธิบายพลังงาน Coulomb กับพลังงาน Exchange 
ระหว่างอิเล็กตรอนแต่ละคู่ซึ่งได้มาจากการแปลง (Transformation) Two-Electron Integrals ให้กลายเป็น Molecular Orbital Basis 
ส่วนเทอมที่อยู่ด้านล่างนั้นก็คือพลังงานของออร์บิทัลซึ่งได้มาจาก Eigenvalues ของวิธี Hartree-Fock นั่นเอง พูดง่าย ๆ ก็คือส่วนผสมที่ใช้ในการคำนวณ 
MP2 นั้นได้มาจาก Hartree-Fock หมดเลย

จากเหตุผลด้านบนนั้นจะสรุปได้ว่าวิธี MP2 นั้นเป็นหนึ่งในวิธีที่คำนวณได้ง่ายที่สุดแล้วของวิธี Electronic Structure ทั้งหมด สำหรับการเขียนโค้ด 
MP2 นั้นจะเห็นได้ว่าเราจะต้องมีการเขียนลูปทั้งหมด 4 ลูป โดยแต่ละลูปจะวนตามจำนวนของออร์บิทัลที่เราสนใจ 

\vspace{5pt}

\noindent เริ่มต้นด้วยการอิมพอร์ตไลบรารี่ที่เราต้องการใช้ก่อน สำหรับโค้ด MP2 เราจะใช้แค่ \pyinline{numpy} ครับ

\vspace{5pt}

\begin{lstlisting}[style=MyPython]
import numpy as np
\end{lstlisting}

\vspace{5pt}

\noindent เรามาเขียนฟังก์ชันสำหรับการคำนวณ Compound Index ของ Integrals แบบ Four-Index กันก่อนครับ

\vspace{5pt}

\begin{lstlisting}[style=MyPython]
def eint(a, b, c, d):
    """
    Return compound index given four indices
    """    
    if a > b:
        ab = a * (a + 1) / 2 + b
    else:
        ab = b * (b + 1) / 2 + a
    if c > d:
        cd = c * (c + 1) / 2 + d
    else:
        cd = d * (d + 1) / 2 + c
    if ab > cd:
        abcd = ab * (ab + 1) / 2 + cd
    else:
        abcd = cd * (cd + 1) / 2 + ab
    return abcd
\end{lstlisting}

\vspace{5pt}

\noindent ต่อด้วยฟังก์ชันสำหรับคำนวณ Integrals 

\vspace{5pt}
    
\begin{lstlisting}[style=MyPython]
def teimo(a, b, c, d):
    """
    Return Value of spatial MO two electron integral
    Example: (12|34) = tei(1,2,3,4)
    """
    return ttmo.get(eint(a, b, c, d), 0.0e0)
\end{lstlisting}

\vspace{5pt}

\noindent ลำดับต่อมาคือการกำหนดค่าเริ่มต้นของพลังงานของออร์บิทัล (Orbital Energies) และ Transformed Two-Electron Integrals

\vspace{5pt}

\begin{lstlisting}[style=MyPython]
Nelec = 2  # 2 electrons in HeH+
dim = 2  # two spatial basis functions in STO-3G
E = [-1.52378656, -0.26763148]
ttmo = {
    5.0: 0.94542695583037617,
    12.0: 0.17535895381500544,
    14.0: 0.12682234020148653,
    17.0: 0.59855327701641903,
    19.0: -0.056821143621433257,
    20.0: 0.74715464784363106,
}
\end{lstlisting}

\vspace{5pt}

\noindent แล้วเราก็ทำการแปลง Spatial Molecular Orbital ให้เป็น Spin Molecular Orbital 

\vspace{5pt}

\begin{lstlisting}[style=MyPython]
# This makes the spin basis double bar integral (physicists' notation).
# We double the dimension (each spatial orbital is now two spin orbitals)

dim = dim * 2
ints = np.zeros((dim, dim, dim, dim))
for p in range(1, dim + 1):
    for q in range(1, dim + 1):
        for r in range(1, dim + 1):
            for s in range(1, dim + 1):
                value1 = (
                    teimo((p + 1) // 2, (r + 1) // 2, (q + 1) // 2, (s + 1) // 2)
                    * (p % 2 == r % 2)
                    * (q % 2 == s % 2)
                )
                value2 = (
                    teimo((p + 1) // 2, (s + 1) // 2, (q + 1) // 2, (r + 1) // 2)
                    * (p % 2 == s % 2)
                    * (q % 2 == r % 2)
                )
                ints[p - 1, q - 1, r - 1, s - 1] = value1 - value2
\end{lstlisting}

\vspace{5pt}

\noindent กำหนด Spin Basis Fock Matrix Eigenvalues

\vspace{5pt}

\begin{lstlisting}[style=MyPython]
fs = np.zeros((dim))
for i in range(0, dim):
    fs[i] = E[i // 2]
# fs = np.diag(fs)
\end{lstlisting}

\vspace{5pt}

\noindent เริ่มการคำนวณ MP2 โดยเราจะทำการวนลูป 2 ลูปแรกก่อนจนครบตามจำนวนของ Occupied Spin Orbitals ซึ่งเท่ากับจำนวนอิเล็กตรอน 
ส่วน 2 ลูปสุดท้ายข้างในเป็นลูปที่จะวนตามจำนวนของ Virtual Orbitals

\vspace{5pt}

\begin{lstlisting}[style=MyPython]
EMP2 = 0.0
for i in range(0, Nelec):
    for j in range(0, Nelec):
        for a in range(Nelec, dim):
            for b in range(Nelec, dim):
                EMP2 += 0.25 * ints[i, j, a, b] * ints[i, j, a, b] / (fs[i] + fs[j] - fs[a] - fs[b])

print("E(MP2) Correlation Energy = ", EMP2, " Hartrees")
\end{lstlisting}

\vspace{5pt}

\noindent เมื่อรันโค้ดด้านบนแล้วจะได้ Correlation Energy ออกมาประมาณ -0.00640 Hartree ซึ่งน้อยมากเมื่อเทียบกับ Electronic 
Energy ของโมเลกุลเดียวกัน ซึ่งถือว่าเป็นเรื่องปกติที่ Correlation Energy นั้นจะมีสัดส่วนที่น้อยกว่าพลังงานอื่น ๆ จากงานวิจัยหลาย ๆ งานพบว่า 
Hartree-Fock นั้นให้ความถูกต้องในการคำนวณพลังงานของโมเลกุลมากถึง 99\% ส่วนอีก 1\% นั้นก็คือพลังงาน Correlation ที่หายไปนั่นเอง 
แต่ถ้าหากว่าเรามาดูรายละเอียดจริง ๆ จะพบว่า 1\% ที่หายไปนั้นไม่น้อยเลย เพราะถ้าหากว่าโมเลกุลของเรามีพลังงานรวมทั้งหมดอยู่ในหลักสิบหรือหลักร้อย 
kcal/mol นั่นหมายความว่าความคลาดเคลื่อนของการที่เราไม่พิจารณา Correlation Energy นั้นมีค่าประมาณ 1\% ซึ่งเกินค่าความถูกต้องทางเคมี 
(Chemical Accuracy) ไปเยอะมาก ดังนั้นการรวม Correlation Effect จึงเป็นสิ่งที่สำคัญมากและถือว่าเป็นหนึ่งในหัวข้องานวิจัยที่สำคัญมาก ๆ 
ของเคมีควอนตัม ในปัจจุบันมีวิธีการต่าง ๆ ที่ถูกพัฒนาขึ้นมาเพื่อใช้ในการคำนวณพลังงานรวมของโมเลกุลโดยรวมผลของ Correlation Effect 
เข้าไปด้วยเพื่อให้ผลการคำนวณนั้นมีค่าถูกต้องและแม่นยำมากที่สุดเท่าที่จะเป็นไปได้

%----------------------------------------
\section{เขียนโปรแกรมคำนวณ Coupled Cluster (ภาษา Python)}
%----------------------------------------

Coupled Cluster with Singles and Doubles (CCSD)

\vspace{5pt}

\begin{lstlisting}[style=MyPython]
import numpy as np
\end{lstlisting}

\vspace{5pt}

\noindent

\vspace{5pt}

\begin{lstlisting}[style=MyPython]
def eint(a, b, c, d):
  """
  Return compound index given four indices
  """
  if a > b:
      ab = a * (a + 1) / 2 + b
  else:
      ab = b * (b + 1) / 2 + a
  if c > d:
      cd = c * (c + 1) / 2 + d
  else:
      cd = d * (d + 1) / 2 + c
  if ab > cd:
      abcd = ab * (ab + 1) / 2 + cd
  else:
      abcd = cd * (cd + 1) / 2 + ab
  return abcd
\end{lstlisting}

\vspace{5pt}

\noindent

\vspace{5pt}

\begin{lstlisting}[style=MyPython]
def teimo(a, b, c, d):
  """
  Return Value of spatial MO two electron integral
  Example: (12|34) = tei(1,2,3,4)
  """
  return ttmo.get(eint(a, b, c, d), 0.0e0)
\end{lstlisting}

\vspace{5pt}

\noindent

\vspace{5pt}

\begin{lstlisting}[style=MyPython]
Nelec = 2  # we have 2 electrons in HeH+
dim = 2  # we have two spatial basis functions in STO-3G
E = [-1.52378656, -0.26763148]  # molecular orbital energies
# python dictionary containing two-electron repulsion integrals
ttmo = {
    5.0: 0.94542695583037617,
    12.0: 0.17535895381500544,
    14.0: 0.12682234020148653,
    17.0: 0.59855327701641903,
    19.0: -0.056821143621433257,
    20.0: 0.74715464784363106,
}
ENUC = 1.1386276671  # nuclear repulsion energy for HeH+
EN = -3.99300007772  # SCF energy
\end{lstlisting}

\vspace{5pt}

\noindent

\vspace{5pt}

\begin{lstlisting}[style=MyPython]
# This makes the spin basis double bar integral (physicists' notation)

spinints = np.zeros((dim * 2, dim * 2, dim * 2, dim * 2))

for p in range(1, dim * 2 + 1):
    for q in range(1, dim * 2 + 1):
        for r in range(1, dim * 2 + 1):
            for s in range(1, dim * 2 + 1):
                value1 = (
                    teimo((p + 1) // 2, (r + 1) // 2, (q + 1) // 2, (s + 1) // 2)
                    * (p % 2 == r % 2)
                    * (q % 2 == s % 2)
                )
                value2 = (
                    teimo((p + 1) // 2, (s + 1) // 2, (q + 1) // 2, (r + 1) // 2)
                    * (p % 2 == s % 2)
                    * (q % 2 == r % 2)
                )
                spinints[p - 1, q - 1, r - 1, s - 1] = value1 - value2
\end{lstlisting}

\vspace{5pt}

\noindent

\vspace{5pt}

\begin{lstlisting}[style=MyPython]
fs = np.zeros((dim * 2))
for i in range(0, dim * 2):
    fs[i] = E[i // 2]
# put MO energies in diagonal array
fs = np.diag(fs)
\end{lstlisting}

\vspace{5pt}

\noindent

\vspace{5pt}

\begin{lstlisting}[style=MyPython]
# twice the dimension of spatial orbital
dim = dim * 2

# Init empty T1 (ts) and T2 (td) arrays
ts = np.zeros((dim, dim))
td = np.zeros((dim, dim, dim, dim))

# Initial guess T2 --- from MP2 calculation!
for a in range(Nelec, dim):
    for b in range(Nelec, dim):
        for i in range(0, Nelec):
            for j in range(0, Nelec):
                td[a, b, i, j] += spinints[i, j, a, b] / (fs[i, i] + fs[j, j] - fs[a, a] - fs[b, b])

# Make denominator arrays Dai, Dabij
# Equation (12) of Stanton
Dai = np.zeros((dim, dim))
for a in range(Nelec, dim):
    for i in range(0, Nelec):
        Dai[a, i] = fs[i, i] - fs[a, a]

# Stanton eq (13)
Dabij = np.zeros((dim, dim, dim, dim))
for a in range(Nelec, dim):
    for b in range(Nelec, dim):
        for i in range(0, Nelec):
            for j in range(0, Nelec):
                Dabij[a, b, i, j] = fs[i, i] + fs[j, j] - fs[a, a] - fs[b, b]


# Stanton eq (9)
def taus(a, b, i, j):
    taus = td[a, b, i, j] + 0.5 * (ts[a, i] * ts[b, j] - ts[b, i] * ts[a, j])
    return taus


# Stanton eq (10)
def tau(a, b, i, j):
    tau = td[a, b, i, j] + ts[a, i] * ts[b, j] - ts[b, i] * ts[a, j]
    return tau
\end{lstlisting}

\noindent

\vspace{5pt}

\begin{lstlisting}[style=MyPython]
def updateintermediates(x):
if x == True:
    # Stanton eq (3)
    Fae = np.zeros((dim, dim))
    for a in range(Nelec, dim):
        for e in range(Nelec, dim):
            Fae[a, e] = (1 - (a == e)) * fs[a, e]
            for m in range(0, Nelec):
                Fae[a, e] += -0.5 * fs[m, e] * ts[a, m]
                for f in range(Nelec, dim):
                    Fae[a, e] += ts[f, m] * spinints[m, a, f, e]
                    for n in range(0, Nelec):
                        Fae[a, e] += -0.5 * taus(a, f, m, n) * spinints[m, n, e, f]

    # Stanton eq (4)
    Fmi = np.zeros((dim, dim))
    for m in range(0, Nelec):
        for i in range(0, Nelec):
            Fmi[m, i] = (1 - (m == i)) * fs[m, i]
            for e in range(Nelec, dim):
                Fmi[m, i] += 0.5 * ts[e, i] * fs[m, e]
                for n in range(0, Nelec):
                    Fmi[m, i] += ts[e, n] * spinints[m, n, i, e]
                    for f in range(Nelec, dim):
                        Fmi[m, i] += 0.5 * taus(e, f, i, n) * spinints[m, n, e, f]

    # Stanton eq (5)
    Fme = np.zeros((dim, dim))
    for m in range(0, Nelec):
        for e in range(Nelec, dim):
            Fme[m, e] = fs[m, e]
            for n in range(0, Nelec):
                for f in range(Nelec, dim):
                    Fme[m, e] += ts[f, n] * spinints[m, n, e, f]

    # Stanton eq (6)
    Wmnij = np.zeros((dim, dim, dim, dim))
    for m in range(0, Nelec):
        for n in range(0, Nelec):
            for i in range(0, Nelec):
                for j in range(0, Nelec):
                    Wmnij[m, n, i, j] = spinints[m, n, i, j]
                    for e in range(Nelec, dim):
                        Wmnij[m, n, i, j] += (
                            ts[e, j] * spinints[m, n, i, e] - ts[e, i] * spinints[m, n, j, e]
                        )
                        for f in range(Nelec, dim):
                            Wmnij[m, n, i, j] += 0.25 * tau(e, f, i, j) * spinints[m, n, e, f]

    # Stanton eq (7)
    Wabef = np.zeros((dim, dim, dim, dim))
    for a in range(Nelec, dim):
        for b in range(Nelec, dim):
            for e in range(Nelec, dim):
                for f in range(Nelec, dim):
                    Wabef[a, b, e, f] = spinints[a, b, e, f]
                    for m in range(0, Nelec):
                        Wabef[a, b, e, f] += (
                            -ts[b, m] * spinints[a, m, e, f] + ts[a, m] * spinints[b, m, e, f]
                        )
                        for n in range(0, Nelec):
                            Wabef[a, b, e, f] += 0.25 * tau(a, b, m, n) * spinints[m, n, e, f]

    # Stanton eq (8)
    Wmbej = np.zeros((dim, dim, dim, dim))
    for m in range(0, Nelec):
        for b in range(Nelec, dim):
            for e in range(Nelec, dim):
                for j in range(0, Nelec):
                    Wmbej[m, b, e, j] = spinints[m, b, e, j]
                    for f in range(Nelec, dim):
                        Wmbej[m, b, e, j] += ts[f, j] * spinints[m, b, e, f]
                    for n in range(0, Nelec):
                        Wmbej[m, b, e, j] += -ts[b, n] * spinints[m, n, e, j]
                        for f in range(Nelec, dim):
                            Wmbej[m, b, e, j] += (
                                -(0.5 * td[f, b, j, n] + ts[f, j] * ts[b, n]) * spinints[m, n, e, f]
                            )

    return Fae, Fmi, Fme, Wmnij, Wabef, Wmbej
\end{lstlisting}

\vspace{5pt}

\noindent

\vspace{5pt}

\begin{lstlisting}[style=MyPython]
# Stanton eq (1)
def makeT1(x, ts, td):
    if x == True:
        tsnew = np.zeros((dim, dim))
        for a in range(Nelec, dim):
            for i in range(0, Nelec):
                tsnew[a, i] = fs[i, a]
                for e in range(Nelec, dim):
                    tsnew[a, i] += ts[e, i] * Fae[a, e]
                for m in range(0, Nelec):
                    tsnew[a, i] += -ts[a, m] * Fmi[m, i]
                    for e in range(Nelec, dim):
                        tsnew[a, i] += td[a, e, i, m] * Fme[m, e]
                        for f in range(Nelec, dim):
                            tsnew[a, i] += -0.5 * td[e, f, i, m] * spinints[m, a, e, f]
                        for n in range(0, Nelec):
                            tsnew[a, i] += -0.5 * td[a, e, m, n] * spinints[n, m, e, i]
                for n in range(0, Nelec):
                    for f in range(Nelec, dim):
                        tsnew[a, i] += -ts[f, n] * spinints[n, a, i, f]
                tsnew[a, i] = tsnew[a, i] / Dai[a, i]
    return tsnew


# Stanton eq (2)
def makeT2(x, ts, td):
    if x == True:
        tdnew = np.zeros((dim, dim, dim, dim))
        for a in range(Nelec, dim):
            for b in range(Nelec, dim):
                for i in range(0, Nelec):
                    for j in range(0, Nelec):
                        tdnew[a, b, i, j] += spinints[i, j, a, b]
                        for e in range(Nelec, dim):
                            tdnew[a, b, i, j] += td[a, e, i, j] * Fae[b, e] - td[b, e, i, j] * Fae[a, e]
                            for m in range(0, Nelec):
                                tdnew[a, b, i, j] += (
                                    -0.5 * td[a, e, i, j] * ts[b, m] * Fme[m, e]
                                    + 0.5 * td[b, e, i, j] * ts[a, m] * Fme[m, e]
                                )
                                continue
                        for m in range(0, Nelec):
                            tdnew[a, b, i, j] += -td[a, b, i, m] * Fmi[m, j] + td[a, b, j, m] * Fmi[m, i]
                            for e in range(Nelec, dim):
                                tdnew[a, b, i, j] += (
                                    -0.5 * td[a, b, i, m] * ts[e, j] * Fme[m, e]
                                    + 0.5 * td[a, b, j, m] * ts[e, i] * Fme[m, e]
                                )
                                continue
                        for e in range(Nelec, dim):
                            tdnew[a, b, i, j] += (
                                ts[e, i] * spinints[a, b, e, j] - ts[e, j] * spinints[a, b, e, i]
                            )
                            for f in range(Nelec, dim):
                                tdnew[a, b, i, j] += 0.5 * tau(e, f, i, j) * Wabef[a, b, e, f]
                                continue
                        for m in range(0, Nelec):
                            tdnew[a, b, i, j] += (
                                -ts[a, m] * spinints[m, b, i, j] + ts[b, m] * spinints[m, a, i, j]
                            )
                            for e in range(Nelec, dim):
                                tdnew[a, b, i, j] += (
                                    td[a, e, i, m] * Wmbej[m, b, e, j]
                                    - ts[e, i] * ts[a, m] * spinints[m, b, e, j]
                                )
                                tdnew[a, b, i, j] += (
                                    -td[a, e, j, m] * Wmbej[m, b, e, i]
                                    + ts[e, j] * ts[a, m] * spinints[m, b, e, i]
                                )
                                tdnew[a, b, i, j] += (
                                    -td[b, e, i, m] * Wmbej[m, a, e, j]
                                    + ts[e, i] * ts[b, m] * spinints[m, a, e, j]
                                )
                                tdnew[a, b, i, j] += (
                                    td[b, e, j, m] * Wmbej[m, a, e, i]
                                    - ts[e, j] * ts[b, m] * spinints[m, a, e, i]
                                )
                                continue
                            for n in range(0, Nelec):
                                tdnew[a, b, i, j] += 0.5 * tau(a, b, m, n) * Wmnij[m, n, i, j]
                                continue
                        tdnew[a, b, i, j] = tdnew[a, b, i, j] / Dabij[a, b, i, j]
        return tdnew


# Expression from Crawford, Schaefer (2000)
# DOI: 10.1002/9780470125915.ch2
# Equation (134) and (173)
# computes CCSD energy given T1 and T2
def ccsdenergy():
    ECCSD = 0.0
    for i in range(0, Nelec):
        for a in range(Nelec, dim):
            ECCSD += fs[i, a] * ts[a, i]
            for j in range(0, Nelec):
                for b in range(Nelec, dim):
                    ECCSD += 0.25 * spinints[i, j, a, b] * td[a, b, i, j] + 0.5 * spinints[i, j, a, b] * (
                        ts[a, i]
                    ) * (ts[b, j])
    return ECCSD
\end{lstlisting}

\vspace{5pt}

\noindent

\vspace{5pt}

\begin{lstlisting}[style=MyPython]
# MAIN LOOP: CCSD iteration
ECCSD = 0
DECC = 1.0
while DECC > 0.000000001:  # arbitrary convergence criteria
    OLDCC = ECCSD
    Fae, Fmi, Fme, Wmnij, Wabef, Wmbej = updateintermediates(True)
    tsnew = makeT1(True, ts, td)
    tdnew = makeT2(True, ts, td)
    ts = tsnew
    td = tdnew
    ECCSD = ccsdenergy()
    DECC = abs(ECCSD - OLDCC)
\end{lstlisting}

\vspace{5pt}

\noindent

\vspace{5pt}

\begin{lstlisting}[style=MyPython]
print("E(corr,CCSD) = ", ECCSD)
print("E(CCSD) = ", ECCSD + ENUC + EN)
\end{lstlisting}

\vspace{5pt}

%----------------------------------------
\section{เขียนโปรแกรมคำนวณ DFT (ภาษา Python)}
%----------------------------------------

%----------------------------------------
\subsection{เขียนโปรแกรมคำนวณ Kohn-Sham Matrix}
%----------------------------------------

%----------------------------------------
\subsection{เขียนโปรแกรมฟังก์ชันนอล LDA}
%----------------------------------------

%----------------------------------------
\subsection{เขียนโปรแกรมฟังก์ชันนอล B3LYP}
%----------------------------------------

%----------------------------------------
\section{เขียนโปรแกรมคำนวณ Molecular Quantum Integrals }
%----------------------------------------

ในหัวข้อนี้ผู้อ่านจะได้เรียนรู้การเขียนโปรแกรมเพื่อคำนวณเทอม Molecular Integrals แบบต่าง ๆ ที่ใช้ Gaussian Basis Functions

%----------------------------------------
\subsection{ความรู้ทางคณิตศาสตร์ที่ต้องใช้}
%----------------------------------------

%----------------------------------------
\subsection{Overlap Integrals}
%----------------------------------------

%----------------------------------------
\subsection{Kinetic Energy Integrals}
%----------------------------------------

%----------------------------------------
\subsection{Nuclear Attraction Integrals}
%----------------------------------------

%----------------------------------------
\subsection{Two-Electron Repulsion Integrals}
%----------------------------------------

%----------------------------------------
\section{เขียนโปรแกรม DIIS สำหรับกระบวนการ SCF (ภาษา C++)}
%----------------------------------------

%----------------------------------------
\section{คำแนะนำสำหรับการคำนวณเคมีควอนตัม}
%----------------------------------------

คนที่ทำวิจัยด้านเคมีควอนตัมก็จะมีเทคนิคหรือแนวทางในการทำการคำนวณเคมีควอนตัมของตนเอง ขึ้นอยู่กับหลายปัจจัย ตัวอย่างเช่น เรียนจากคอร์ส%
ของมหาวิทยาลัย, อ่านจากหนังสือหรือตำราต่างประเทศที่ต่างกัน, ได้รับคำชี้แนะจากการทำวิจัยจากหลาย ๆ คน รวมถึงประสบการณ์หรือความเคยชิน%
กับโปรแกรมเคมีควอนตัมที่ตนเองถนัด อย่างไรก็ตาม ผมคิดว่าเราทุกคนควรจะต้องมีหลักการทางทฤษฎีที่ถูกต้องที่ควรจะต้องปฏิบัติตามกัน ซึ่งก็คือการเข้า%
ใจทฤษฎีทางเคมีควอนตัมและโครงสร้างเชิงอิเล็กทรอนิกส์ ในหัวนี้ผู้อ่านได้จะศึกษาแนวทางสำหรับการคำนวณเคมีควอนตัม

\paragraph{1. การเตรียม Input File โครงสร้างของโมเลกุลและการเลือก Electronic State}
ผมขอเริ่มด้วยสิ่งที่เป็นพื้นฐานที่สุดนั่นก็คือการเตรียมไฟล์อินพุต (Input) ซึ่งปกติแล้วเรามักจะทราบกันดีว่าเราสามารถแสดง (Represent)
โครงสร้างของโมเลกุลได้ด้วยรูปแบบ (Format) 2 อัน นั่นคือ Cartesian (xyz) Format กับ z-matrix Format โดยใน xyz Format
นั้นเราจะใส่ลิสต์รายละเอียดของอะตอมในโมเลกุลนั่นคือเลขอะตอมและพิกัด Cartesian Coordinate ของอะตอมแต่ละตัว ส่วนใน z-matrix
Format นั้นจะเป็นการกำหนดโครงสร้างหรือ Geometry โดยการใช้พิกัดภายใน (Internal Coordinates) เช่น ควาามยาวพันธะ มุมพันธะ
และมุมบิด โดยโปรแกรมควอนตัมเคมีส่วนใหญ่นั้นทำการกำหนดรูปแบบเริ่มต้นของโครงสร้างโมเลกุลเป็นแบบพิกัด xyz รวมถึงพารามิเตอร์อื่น ๆ
เช่น กำหนดหน่วยเป็น Angstroms แต่ว่าโปรแกรมแต่ละโปรแกรมนั้นก็มักจะมีคีเวิร์ดให้สลับไปใช้หน่วยอื่น เช่น bohr พารามิเตอร์ที่สำคัญอีก 2
อันก็คือ Charge กับ Spin Multiplicity ของ Electronic State ที่เราสนใจที่จะศึกษา โดยประจุนั้นเป็นการระบุถึงจำนวนของอิเล็กตรอน
ส่วน Spin Multiplicity หาได้จากจำนวนรูปแบบที่อิเล็กตรอนสามารถจัดคู่ได้ซึ่งเขียนแทนด้วย $\ket{\Psi}$ สำหรับแต่ละ Configuration
นั่นเอง ตัวอย่างเช่น โมเลกุลมีเทน \ce{CH4} เรากำหนดประจุเป็น 0 ส่วน Spin Multiplicity นั้นเป็น 1 เพราะว่าจำนวน Alpha Electron
กับ Beta Electron นั้นเท่ากันใน Singlet State ดังนั้นจึงมี Configuration ได้แบบเดียว

\paragraph{2. การเลือก Basis Set}
ลำดับต่อมาคือเราจะต้องเลือก Basis Set ที่ต้องการใช้ อันนี้ก็เป็นปัญหาโลกแตกอีกอันหนึ่งในทางเคมีควอนตัม แต่ละคนก็จะมี Basis Set
ที่ตัวเองชอบหรือจะต้องใช้ Basis Set ที่โดนบังคับให้ใช้ อย่างไรก็ตาม ผมขำแบ่งคำแนะนำเบื้องต้นในการเลือก Basis Set ออกเป็น 2 กลุ่มหลัก ๆ
คือ Basis Set สำหรับการคำนวณด้วย DFT Method และด้วย Wavefunction-based Method

\begin{enumerate}
  \item สำหรับการคำนวณ Density Functional Theory (DFT) และ Hartree-Fock (HF) นั้นเรามักจะมีตัวเลือกทั่ว ๆ ไป เช่น
        6-31G(d), 6-31G(d,p) แต่ถ้าเป็นไปได้ก็ไปใช้ Basis Set อื่นที่ใหม่กว่านี้ดีกว่า (มีบทความวิชาการรีวิวที่ให้เหตุผลว่าทำไมเราถึงไม่ควรใช้
        Pople's Basis ตัวเล็ก ๆ) ถ้าเป็นไปได้ให้ลองใช้ Basis Set จากสำนัก Karlsruhe เช่น def2-SVP, def2-TZVP, def2-QZVP
        ถ้าหากว่าเราต้องมีการคำนวณเยอะมาก ๆ ผมแนะนำตัว def2-TZVP เพราะว่าจะให้ผลการคำนวณทั้งหมดที่ Converge ดีกว่า

  \item สำหรับ Wavefunction-based Method เช่น MP2, CCSD, CCSD(T) นั่น แนะนำให้ใช้จากสำนักของ Dunning ที่เป็นตัว
        Correlation Consistent เช่น cc-pVXZ ตัวอย่างคือ cc-pVDZ, cc-pVTZ เป็นต้น ซึ่ง Basis Set ของตระกูลนี้มักจะให้ผลการคำนวณที่
        Converge หรือว่าเข้าใกล้ Full Basis Set Limit นั่นเอง ถ้าต้องการคำนวณที่แม่นยำและถูกต้องมาก ๆ ก็ใช้ตัวใหญ่ ๆ ไปเลย
        เช่น cc-pV5Z

  \item ถ้าต้องการศึกษาระบบโมเลกุลที่เกี่ยวข้องกับ Rydberg States, Long-range Interaction, หรือประจุลบ (Anions)
        ควรจะต้องใช้ Basis Set ที่มี Diffuse Function ใส่เข้าไปด้วย เช่น เรามักจะเห็นว่ามีสัญลักษณ์เครื่องหมาย + หรือตัว D อยู่ใน
        Basis Set ถ้าเป็นของตระกูล Correlation-Consistent ก็จะเติมคำว่า "aug" เข้าไปข้างหน้า

  \item Basis Set ของ Dunning นั้นถูกออกแบบมาให้เหมาะกับการ Correlate แค่อิเล็กตรอนที่อยู่วงนอกเท่านั้น (Valence Electrons)
        ซึ่งในการใช้งานจริง ๆ นั้นเราควรจะต้อง treat อิเล็กตรอนข้างใน (Core Electrons) แบบ Frozen หรือเราควรจะต้องใช้
        Core-valence Set เช่น cc-pwCVDZ
\end{enumerate}

\paragraph{3. การคำนวณที่ Ground State}
ในการเริ่มโปรเจ็คใหม่นั้นเราอย่าเพิ่งรีบร้อนใช้วิธีที่อลังการงานสร้างเกินไปเพราะอาจจะสิ้นเปลืองการคำนวณได้ง่าย ๆ ดังนั้นควรเริ่มด้วยวิธีเบา ๆ เร็ว ๆ
ในช่วงวันแข่งวิ่งจริง เช่น รันด้วยวิธี DFT แล้วก็ใช้ Basis Set กลาง ๆ เช่น def-SVP แล้วก็ใช้ Functional พื้นฐาน เช่น B3LYP
(ปัญหาโลกแตกอีกอันหนึ่งคือเลือกใช้ Functional ตามความชอบ แล้วค่อยมาเเตรียมอีกครั้งตอนคำนวณจริง ๆ ที่ต้องการผลการคำนวณที่ถูกต้องไป%
ตีพิมพ์หรือนำเสนอต่อไป) ซึ่งวิธี DFT นั้นมี Computational Demand ที่ต่ำ $\mathcal{O}(N^{4})$ เอง โดย $N$ คือจำนวนอิเล็กตรอนหรือ
Basis Functions เมื่อเราพอมีผลการคำนวณระดับหนึ่งแล้วเราอาจจะใช้วิธีการที่สูงหรือซับซ้อนขึ้น ซึ่งจะให้ผลการคำนวณที่ถูกต้องขึ้นแต่ก็แลกมา%
ด้วยการคำนวณที่สิ้นเปลืองกว่า DFT เช่น MP2, MP3 เพราะว่ามันสเกลตาม $\mathcal{O}(N^{5})$ อย่างไรก็ตามต้องอย่าลืมว่าวิธี MPn
มันไม่ได้ให้ผลที่ Converge หมายความว่ายิ่งเราเพิ่ม Order ของ Perturbation ไม่ได้หมายความว่าความถูกต้องนั้นมันจะมีมากขึ้นเรื่อย ๆ
ซึ่งถ้าอยากใช้วิธี MPn ที่ Order สูง ๆ ให้ไปใช้วิธีอื่นที่แฟนซีมากกว่านี้ดีกว่า เช่น Coupled Cluster (CC) Method สำหรับ CC นั้นก็ใช้เริ่มด้วย
CCSD ก่อนก็ได้ แต่ว่าก็ไม่ได้ให้ผลการคำนวณที่ถูกต้องมากนักถ้าเทียบกับ CCSD(T) ซึ่งสิ้นเปลืองกว่าหน่อยนึงแต่ว่าให้ผลการคำนวณที่ถูกต้องกว่ามาก
แต่ขึ้นชื่อว่า CC มันย่อมสิ้นเปลืองอยู่แล้ว ซึ่งวิธี CC นั้นมีสเกลถึง $\mathcal{O}(N^{6})$

\paragraph{4. การคำนวณที่ Excited State}
ถ้าอยากจะคำนวณ Electronic Structure ของโมเลกุลที่ Excited State ก็ให้เริ่มด้วย Time-dependent DFT (TDDFT) ก็ได้ ถึงแม้ว่าวิธี
TDDFT ไม่สามารถให้ผลการคำนวณที่ถูกต้องได้ในหลาย ๆ กรณีก็ตาม แต่ว่าก็ไม่ได้ให้ผลการคำนวณทั่ว ๆ ไปของ Excited State ที่แย่มากนัก
นอกจากนี้วิธี TDDFT นั้นจริง ๆ แล้วก็ไม่ได้สิ้นเปลืองมากนัก เพราะว่าตัว Formalism นั้นแบบเดียวกันกับวิธี DFT เลยคือการสร้าง Density Matrix
แล้วก็ทำ Diagonalization สำหรับการใช้วิธี TDDFT นั้นเราก็ควรจะใช้ Functional พิเศษที่ถูกดีไซน์มาเพื่อ Excited State ด้วย เพราะว่า
Functional พวกนี้มันจะสามารถอธิบายเหตุการณ์บางอย่างได้ เช่น Rydberg Effect หรือการกระตุ้นของ Charge/Electron Transfer
ซึ่งจำเป็นมาก ๆ โดยเฉพาะการคำนวณพวก Spectra ต่าง ๆ สำหรับวิธี Wavefunction-based Method นั้นก็ให้เริ่มด้วยวิธี Configuration
Interaction ที่ใส่ Single Excitation เข้าไป เรียกว่า CIS ซึ่งเป็นวิ��ีที่ทำการรวม Slater Determinant ของ Singly Excited
นั่นเองซึ่งได้มาจากการคำนวณที่มีการกระตุ้นอิเล็กตรอนหนึ่งตัวขึ้นไปใน Virtual Orbital \footnote{Virtual Orbital ก็คือ Unoccupied
  Orbital หรือออร์บิทัลที่ไม่มีอิเล็กตรอนอยู่ในสภาวะพื้น} ถึงแม้ว่า CIS จะไม่แม่นยำแต่ก็ไม่สิ้นเปลืองเลย ส่วนถ้าอยากจะใช้วิธี Coupled Cluster
สำหรับศึกษา Excited State นั้นจะต้องใช้สิ่งที่เรีบกว่า Equation-of-Motion เข้ามาช่วย ซึ่งก็คือวิธี EOM-CC หรือถ้าอีกวิธีก็คือใช้ Linear
Response เรียกว่า LR-CC โดยวิธี EOM-CC นั้นโคตรสิ้นเปลืองแต่ว่าให้ผลที่ถูกต้องมาก นอกจากนี้ยังมีวิธีอื่นอีก เช่น Algebraic Diagrammatic
Construction (ADC) หรือ CC2, CC3 ซึ่งเป็น Approximation แบบหนึ่งของ EOM-CC ซึ่งจะสิ้นเปลืองน้อยกว่า

\paragraph{5. การแก้ปัญหาที่เกิดขึ้นในการคำนวณเคมีควอนตัม}
คราวนี้เราลองมาดูปัญหายอดฮิตที่เรามักจะเจอกันรวมถึงวิธีหรือคำแนะนำในการแก้ปัญหา ซึ่งปัญหาหลักที่ผมจะเน้นนั้นก็คือการที่ Self-Consistent Field
(SCF) Calculation นั้นไม่ Converge วิธีการแก้ที่อาจจะลองเอาไปใช้คือ

\begin{enumerate}
  \item เพิ่มจำนวนรอบของการรัน SCF

  \item เปลี่ยน Initial Orbital Guess เริ่มต้นที่เราเอามาใช้ในการสร้างฟังก์ชันคลื่น

  \item เปลี่ยน Basis Set ซึ่งให้ลองใช้ Basis Set ที่มีขนาดเล็กลงมาแล้วก็ค่อยเอาไปใช้เป็น Orbital Guess สำหรับการคำนวณที่ใช้
        Basis Set ใหญ่กว่าได้

  \item ใช้ Trick อื่น ๆ เช่น ปรับ Level Shift ซึ่งเป็นการปรับพลังงานของ Virtual Orbitals ซึ่งมีประโยชน์มากสำหรับระบบโมเลกุล%
        บางอันที่ซับซ้อน เช่น Biradical หรือ Triplet State
\end{enumerate}

\paragraph{6. ทำ Stability Analysis หลังการรันทุกครั้ง}
หลายคนนั้นหลังจากที่รันการคำนวณเสร็จแล้วก็มักจะดีใจและนำค่าต่าง ๆ จาก Output File ที่ได้จากการคำนวณมาใช้ ซึ่งการทำแบบนี้นั้นจริง ๆ
แล้วถือว่าเสี่ยงมาก ถึงแม้ว่าระบบโมเลกุลที่เราคำนวณนั้นจะเล็กก็ตาม ที่ผมบอกว่าเสี่ยงนั้นหมายความว่าผลการคำนวณที่เราได้ออกมานั้นอาจจะผิดได้
ยกตัวอย่างเช่นโมเลกุล \ce{N2} นั้นบางครั้งให้ผลการคำนวณที่ไม่สมเหตุสมผลมาก ๆ โดยปัญหาที่ทราบกันดีนั่นก็คือพลังงานของ LUMO ต่ำกว่าของ
HOMO ซึ่งเป็นไปไม่ได้เลย เหตุผลก็คือ SCF นั้นมัน Converge เข้าไปหา Electronic State ที่ผิดเพราะว่าเกิดจาก Guess เริ่มต้นที่ใช้ในการคำนวณ
SCF นั้นผิด โดยเกี่ยวข้องกับ Occupation ของออร์บิทัลที่มาจาก Symmetry หรือสมมาตรของโมเลกุลนั่นเอง โดย \ce{N2} นั้นมี Irreducible
Representation ทั้งหมด 8 อัน ($D_{2h}$) ซึ่ง SCF นั้นจะต้องเดาว่ามีจำนวน Irreducible Representation เท่าไหร่ที่จะต้องนำมา%
อิเล็กตรอนเข้ามาใส่ ถ้าหากว่าเดาผิดก็จะทำให้ SCF นั้นผิดและทำให้เลข Occupation Number นั้นผิดไปด้วย วิธีการเช็คง่าย ๆ คือให้ดูที่
Occupation ของ Doubly Occupied Orbitals โดยโปรแกรมแต่ละโปรแกรมก็จะมี Keyword ที่เราสามารถใช้ในการเช็ค Stability
ของฟังก์ชันคลื่นที่ต่างกันไป

\paragraph{7. การปรับโครงสร้างโมเลกุล (Geometry optimization)}
การปรับโครงสร้างโมเลกุล (Geometry Optimization) นั้นเป็นสิ่งที่ทุกคนนั้นจะต้องมีประสบการณ์ทำกันมาแล้วทั้งนั้น คำแนะนำสำหรับการรัน
Geometry Optimization มีดังนี้ครับ

\begin{enumerate}
  \item การรัน Geometry Optimization นั้นใช้เวลานานกว่าจะ Converge เพราะว่าโครงสร้างนั้นจะต้องประมาณค่าของ Hessian
        Matrix แทนที่จะคำนวณหา Hessian ที่ถูกต้อง ดังนั้นเราควรเริ่มด้วยการใช้ Full Hessian Matrix เพื่อทำให้ Converge เร็วขึ้น

  \item โมเลกุลบางระบบปรับโครงสร้างได้ยากมาก ๆ การที่เราใช้ Coordinate System ที่ซับซ้อนก็อาจจะช่วยทำให้การรันสามารถ Converge ได้

  \item เมื่อสามารถหา Stationary Point ได้แล้ว ให้ทำการคำนวณ Frequency Analysis เพื่อตรวจสอบว่าโครงสร้างที่เราได้นั้นเป็น
        Local Minimum หรือ Transition State กันแน่

  \item เราไม่ควรเริ่มการปรับโครงสร้างด้วยการใช้โครงสร้างที่มี Symmetry สูง ๆ เช่น $D_{2h}$ เพราะว่าโดยหลักการแล้วตัว Optimizer
        นั้นไม่สามารถปรับโครงสร้างโมเลกุลจาก High symmetry ไปยังโครงสร้างที่มี Low symmetry ได้ ดังนั้นเราควรเริ่มด้วยการไม่ใช้ Symmetry
        และปล่อยให้ Optimizer นั้นมันเช็คเองว่าโครงสร้างอันนั้นมีสมมาตรหรือเปล่า
\end{enumerate}

%----------------------------------------
\section{แบบฝึกหัด}
%----------------------------------------
