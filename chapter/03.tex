% LaTeX source for ``Algorithms for Computer Simulation of Molecular Systems''
% Copyright (c) 2023 รังสิมันต์ เกษแก้ว (Rangsiman Ketkaew).

% License: Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)
% https://creativecommons.org/licenses/by-nc-nd/4.0/

\chapter{พลวัตเชิงโมเลกุลแบบแอบ อินิชิโอ}
\label{ch:aimd}

%----------------------------------------
\section{ทำไมต้อง \textit{Ab Initio} Molecular Dynamics}
%----------------------------------------

เทคนิคการจำลองแบบ Molecular Dynamics (MD) แบบดั้งเดิมหรือ Classical MD นั้นจะใช้ Potential ที่ได้มาจากการใช้ข้อมูลเชิงการทดลอง
(Empirical Data) หรือจากการคำนวณ Electronic Structure และหัวใจสำคัญของ MD นั้นก็คือสมการที่ใช้ในการอธิบายอันตรกิริยาระหว่างอะตอม
(Interatomic Interactions) โดยอันตรกิริยาที่เกิดขึ้นทั้งหมดนั้นเราสามารถแบ่งออกได้เป็นหลาย ๆ ส่วน คือ

\begin{itemize}[topsep=0pt,noitemsep]
  \setlength\itemsep{0.5em}
  \item Two-Body Contribution

  \item Three-Body Contribution

  \item Many-Body Contribution

  \item Long-Range Interaction

  \item Short-Range Interaction

  \item เทอมอื่น ๆ
\end{itemize}

จุดเริ่มต้นของเทคนิคการจำลองทางเคมีคอมพิวเตอร์แบบใหม่ที่เกิดขึ้นมาจากการนำวิธี MD และ Electronic Structure มารวมกันนั้นเรียกว่า
\textit{ab initio} Molecular Dynamics (AIMD) ซึ่งอาจจะมีชื่อเรียกอื่น ๆ ที่เราอาจจะคุ้นเคยกันมาบ้าง เช่น

\begin{itemize}[topsep=0pt,noitemsep]
  \setlength\itemsep{0.5em}
  \item Car-Parrinello Molecular Dynamics

  \item Hellmann-Feynman Molecular Dynamics

  \item First Principles Molecular Dynamics

  \item Quantum Chemical Molecular Dynamics

  \item On-The-Fly Molecular Dynamics

  \item Direct Molecular Dynamics

  \item Potential-Free Molecular Dynamics

  \item Quantum Molecular Dynamics
\end{itemize}

แต่ไอเดียพื้นฐานที่เป็นหัวใจสำคัญของวิธีการคำนวณแบบ AIMD ทุกวิธีนั้นก็คือการคำนวณแรง (Force) ที่กระทำระหว่างอะตอมโดยการใช้วิธี
Electronic Structure ในแต่ละ Step ของการคำนวณ MD

การประยุกต์ใช้วิธี AIMD นั้นกว้างขวางมาก ๆ โดยเฉพาะในด้านวัสดุศาสตร์และเคมี จะเห็นได้จากจำนวนงานบทความงานวิจัยเกี่ยวกับ AIMD
ที่ได้รับการตีพิมพ์เพิ่มมากขึ้นเรื่อย ๆ ทุกปี ซึ่งจุดเริ่มต้นนั้นก็มาจากเปเปอร์ของ Car และ Parrinello ที่ตีพิมพ์ในปี 1985 นั่นคือ
\enquote{Uniﬁed Approach for Molecular Dynamics and Density-Functional Theory} ที่ทำให้งานวิจัยทางด้านนี้นั้นได้รับความสนใจ

อย่างไรก็ตาม ถึงแม้ว่าวิธี AIMD นั้นจะทำให้การคำนวณ MD นั้นมีความแม่นยำเพิ่มมากขึ้น แต่ว่าราคาที่นักคำนวณจะต้องจ่ายก็คือความสิ้นเปลืองในการคำนวณ
(Computational Cost) ในการนำ MD ไปผสมรวมกับวิธี \textit{ab initio} นั่นก็คือความสัมพันธ์ระหว่าง Length และ Relaxation Time
ที่เราสามารถรันการคำนวณด้วยแบบจำลอง AIMD นั้นสั้นมาก ๆ เมื่อเทียบกับวิธี MD ทั่วไป (สำหรับระบบโมเลกุลเดียวกัน) ถึงแม้ว่าข้อเสียของวิธี AIMD
นั้นคือใช้เวลาในการคำนวณที่นานกว่า MD เยอะมาก ๆ แต่ว่าเราก็อย่าลืมไปว่าวิธี AIMD นั้นมีข้อดีอีกหลายข้อเลยที่เราจะไม่พูดถึงก็ไม่ได้
ข้อดีอย่างแรกก็คือวิธี AIMD สามารถให้ผลการคำนวณที่สอดคล้องกับ Physical Picture จริง ๆ ของระบบที่เราจำลอง ข้อดีอีกอย่างก็คือวิธี AIMD
นั้นสามารถช่วยให้เราสามารถจำลองปรากฏการณ์ของระบบโมเลกุลที่ไม่สามารถเกิดขึ้นได้ในการจำลองด้วยวิธี MD

จริง ๆ แล้วก่อนที่จะมีการพัฒนาวิธี AIMD ขึ้นมานั้น ในอดีตก็มีวิธีที่คล้าย ๆ กันเรียกว่า \enquote{Classical Trajectory Calculation}
ซึ่งมีจุดเริ่มต้นคือคำนวณระบบ Gas Phase ด้วยวิธี MD เพื่อศึกษา \enquote{Global} Potential Energy Surface (PES)
หรือพื้นผิวพลังงานศักย์ แล้วก็ตามด้วยการคำนวณ Dynamical Evolution ของระบบโดยการใช้ Classical Mechanics หรือ Quantum Mechanics
หรือ Semi/Quasiclassical Approximations ซึ่งในกรณีที่ใช้วิธี Classical Mechanics ในการอธิบาย Dynamics ของระบบโมเลกุลนั้น%
มีอุปสรรคก็คือขนาดของระบบ กล่าวคือ ยิ่งระบบมีขนาดใหญ่ การใช้วิธี Classical Mechanics นั้นก็จะยิ่งทำได้ยาก (สิ้นเปลืองการคำนวณ)
นั่นก็เพราะว่าระบบที่มี $N$ อะตอมนั้นก็จะมีจำนวนดีกรีของความอิสระ (Degree of Freedom) เท่ากับ $3N - 6$ ที่จะเป็นตัวกำหนดขนาดของ PES
แล้วถ้าหากว่าเราใช้จำนวน Discretization Points เช่น 10 Points ต่อ Coordinate นั่นคือเรามีจำนวนการคำนวณ Electronic Structure
ที่จะต้องคำนวณเท่ากับ $10^{3N - 6}$ เพื่อที่ทำการ Mapping เพื่อให้ได้ Global PES ของระบบโมเลกุลของเราออกมา
ดังนั้นความสิ้นเปลืองของวิธีแรกนั้นเท่ากับ $10^{N}$ ซึ่งเพิ่มตามขนาดของระบบ ซึ่งเราเรียกปัญหานี้ว่า \enquote{Dimensionality Bottleneck}

คำถามคือ \enquote{ถ้าหากอยากจะรู้ว่า AIMD สิ้นเปลืองแค่ไหน เราจะต้องคำนึงถึงอะไรบ้าง?} ในการตอบคำถามนี้ผมขอเริ่มด้วยการยกตัวอย่างต่อไปนี้
สมมติว่าเรามี Trajectory ของการคำนวณ MD ที่มีจำนวนทั้งหมด $10^{M}$ Steps (ก็คือมีทั้งหมด $10^{M}$ Configurations)
นั่นคือจะต้องมีการคำนวณ Electronic Structure ทั้งหมด $10^{M}$ ครั้ง ถ้าหากว่ามีจำนวน Independent Trajectory ทั้งหมด $10^{n}$
Trajectories ที่จำเป็นที่จะต้องคำนวณเพื่อทำการเฉลี่ย Initial Conditions ดังนั้นจึงมีการคำนวณ AIMD ทั้งหมด $10^{M + n}$
การคำนวณที่จะต้องทำการรัน ลำดับสุดท้าย ถ้าหากว่าเราจะต้องทำการคำนวณ Single-Point Electronic Structure เพื่อคำนวณ Global PES
และแต่ละการคำนวณของ AIMD นั้นใช้เวลา CPU Time เท่ากัน จากข้อมูลทั้งหมดที่เราอ้างขึ้นมาตามสถานการณ์ความเป็นจริงนั้น เราจะสรุปได้ว่าการใช้
AIMD ในการคำนวณ Global PES นั้นจะมีความสิ้นเปลืองอยู่ที่ประมาณ $10^{3N-6-M-n}$ ประเด็นสำคัญก็คือว่า สำหรับระบบที่มี $M$ และ $n$
คงที่และไม่ขึ้นกับ $N$ นั้น การคำนวณ AIMD จะมี Advantage เป็นแบบ \enquote{On-The-Fly} ซึ่งจะมีความสิ้นเปลืองของวิธีคือ $10^{N}$
เพิ่มขึ้นตามขนาดของระบบ

อย่างไรก็ตาม ความสิ้นเปลืองของวิธี AIMD ที่ประมาณ $10^{N}$ นั้นก็ยังเยอะอยู่ดี ดังนั้นจึงได้มีการพัฒนาเทคนิคต่าง ๆ ขึ้นมาเพื่อใช้ในการลดจำนวน
Degrees of Freedom แต่ว่าเทคนิคเหล่านั้นก็เป็นการใช้ Approximations (การประมาณ) เสียส่วนใหญ่ นั่นจึงทำให้ความถูกต้องของ AIMD นั้นลดลงด้วย

ในบทนี้ผมจะพาผู้อ่านทุกท่านไปทำความรู้จักกับวิธี AIMD ซึ่งเป็นภาพรวมกว้าง ๆ โดยเราจะเริ่มต้นกันด้วยสมการ Schr\"{o}dinger แล้วก็จะมีการพูดถึง
Classical MD, Ehrenfest MD, Born-Oppenheimer, และ Car-Parrinello MD ซึ่งเป็นวิธีที่ได้มาจากวิธี Time-Dependent Mean-Field
Approach ซึ่งได้หลังจากการที่เราทำการแยก Degrees of Freedom ของนิวเคลียสกับอิเล็กตรอนออกจากกัน นอกจากนี้ยังมีอีกหนึ่งเรื่องสำคัญที่ผู้อ่าน%
จะได้ศึกษานั่นคือการคำนวณแรง (Force) ของวิธีต่าง ๆ ด้วย ซึ่งหนึ่งในวิธีที่ถูกนำมาใช้ในการคำนวณ Force ที่ได้รับความนิยมเป็นอย่างมากนั่นคือ
Density Functional Theory (DFT) ดังนั้นเราจึงสามารถเรียกวิธีที่ใช้ในการจำลอง AIMD ที่มีความถูกต้องของการคำนวณ Electronic Structure
ในแต่ละ Step ของ MD ได้ว่า Density Functional Theory-based Molecular Dynamics หรือ DFT-MD

%----------------------------------------
\section{จาก MD สู่ \textit{Ab Initio} MD}
%----------------------------------------

เรามาเริ่มกันที่สมการ Time-Dependent Schr\"{o}dinger Equation ซึ่งเราต่างก็ทราบกันดีอยู่แล้วว่าเป็นสมการที่ฟังก์ชันคลื่น (Wavefunction)
นั้นเป็นฟังก์ชันที่ขึ้นกับตำแหน่งของอนุภาคที่เราสนใจและเวลา โดยอนุภาคที่เราสนใจในที่นี้ก็คืออิเล็กตรอนและนิวเคลียส

\begin{equation}
  \label{eq:AIMD_TDSE}
  i \hbar \frac{\partial}{\partial t} \Phi\left(\mathbf{r}_i,\mathbf{R}_I ; t\right)
  =
  H \Phi\left(\mathbf{r}_i,\mathbf{R}_I ; t\right)
\end{equation}

\noindent ซึ่งมี Position Representation ที่เชื่อมโยงกับ Standard Hamiltonian ซึ่งมีนิยามดังต่อไปนี้ (มี 5 เทอมรวมเข้าด้วยกัน)

\begin{equation}
  \label{eq:AIMD_Hamiltonian}
  \begin{aligned}
    H
     & = -\sum_I \frac{\hbar^2}{2 M_I} \nabla_I^2
    -\sum_i \frac{\hbar^2}{2 m_{\mathrm{e}}} \nabla_i^2
    +\sum_{i<j} \frac{\mathrm{e}^2}{\left|\mathbf{r}_i-\mathbf{r}_j\right|}
    -\sum_{I, i} \frac{\mathrm{e}^2 Z_I}{\left|\mathbf{R}_I-\mathbf{r}_i\right|}
    +\sum_{I<J} \frac{\mathrm{e}^2 Z_I Z_J}{\left|\mathbf{R}_I-\mathbf{R}_J\right|} \\
     & = -\sum_I \frac{\hbar^2}{2 M_I} \nabla_I^2
    -\sum_i \frac{\hbar^2}{2 m_{\mathrm{e}}} \nabla_i^2
    +V_{\mathrm{n}-\mathrm{e}}\left(\mathbf{r}_i,\mathbf{R}_I\right)                \\
     & = -\sum_I \frac{\hbar^2}{2 M_I} \nabla_I^2
    +H_{\mathrm{e}}\left(\mathbf{r}_i,\mathbf{R}_I\right)
  \end{aligned}
\end{equation}

\noindent สำหรับระดับของความอิสระ (Degrees of Freedom) ของอิเล็กทรอนิกส์ $\mathbf{r}_i$ กับของนิวเคลียร์ $\mathbf{R}_I$
แล้วเราก็จะใช้ Atomic Units (a.u.) เพื่อช่วยให้สมการต่าง ๆ ของเรานั้นดูง่ายและชัดเจนมากขึ้น ดังนั้นเราจะสนใจเทอมที่เป็นอันตรกิริยาระหว่าง
อิเล็กตรอน-อิเล็กตรอน (Electron-Electron), อิเล็กตรอน-นิวเคลียร์ (Electron-Nuclear), และนิวเคลียร์-นิวเคลียร์แบบคูลอมป์
(Nuclear-Nuclear Coulomb) เป็นพิเศษ

เป้าหมายของหัวข้อนี้ก็คือการพิสูจน์ที่มาของ Classical Molecular Dynamics โดยเริ่มจากสมการคลื่นของ Schr\"{o}dinger ซึ่งถึงตรงนี้แล้ว
เราจะทำการแยกฟังก์ชันคลื่นรวมของระบบโมเลกุลของเราออกเป็น 2 พาร์ท $\Phi\left(\mathbf{r}_i,\mathbf{R}_I ; t\right)$
นั่นก็คือพาร์ทที่ขึ้นกับ Nuclear Coordinates และพาร์ทที่ขึ้นกับ Electronic Coordinates ซึ่งจะสามารถเขียนให้อยู่ในรูปที่ง่ายที่สุดได้โดยใช้
ผลคูณระหว่าง Ansatz ดังนี้

\begin{equation}
  \label{eq:simplest_product_ansatz}
  \Phi\left(\mathbf{r}_i,\mathbf{R}_I ; t\right)
  \approx
  \Psi\left(\mathbf{r}_i ; t\right)
  \chi\left(\mathbf{R}_I ; t\right)
  \exp \left[\frac{i}{\hbar} \int_{t_0}^t d t^{\prime} \tilde{E}_{\mathrm{e}}\left(t^{\prime}\right)\right]
\end{equation}

\noindent โดยที่ Nuclear Wavefunction และ Electronic Wavefunction นั้นถูกแยกออกจากกันอย่างสิ้นเชิงและถูก Normalized ในแต่ละ
Time Step ด้วย ดังนี้ $\langle\chi ; t \mid \chi ; t\rangle=1$ และ $\langle\Psi ; t \mid \Psi ; t\rangle=1$ ตามลำดับ
นอกจากนี้แล้วเรายังมีการกำหนดพารามิเตอร์อีกตัวหนึ่งขึ้นมานั่นคือ Phase Factor ดังนี้

\begin{equation}
  \tilde{E}_{\mathrm{e}}
  =
  \int d \mathbf{r} d \mathbf{R} \Psi^{\star}\left(\mathbf{r}_i ; t\right)
  \chi^{\star}\left(\mathbf{R}_I ; t\right)
  H_{\mathrm{e}} \Psi\left(\mathbf{r}_i ; t\right)
  \chi\left(\mathbf{R}_I ; t\right)
\end{equation}

\noindent เพื่อที่จะทำให้สมการสุดท้ายที่เราได้ออกมานั้นมีหน้าตาที่ดูสั้นและกระชับ ดังนี้ $\int d \mathbf{r} d \mathbf{R}$ ซึ่งเป็นการคำนวณ
Integration ทั่วทั้งหมดโมเลกุล $i=1, \ldots$ และ $I=1, \ldots$ สำหรับตัวแปร $\mathbf{r}_i$ และ $\mathbf{R}_I$ ตามลำดับ

นอกจากนี้แล้วเราต้องทราบกันไว้ด้วยว่า Product Ansatz (ที่ไม่รวม Phase Factor) ตามด้านบนนั้นมีความแตกต่างจาก Ansatz ของ
Born-Oppenheimer ซึ่งเป็นการแยกพาร์ทที่คำนวณได้เร็วกว่าและพาร์ทที่คำนวณได้ช้ากว่าออกจากกัน ดังนี้

\begin{tcolorbox}[ams equation]
  \Phi_{\mathrm{BO}}\left(\mathbf{r}_i,\mathbf{R}_I ; t\right)
  =
  \sum_{k=0}^{\infty}
  \tilde{\Psi}_k\left(\mathbf{r}_i,\mathbf{R}_I\right)
  \tilde{\chi}_k\left(\mathbf{R}_I ; t\right)
\end{tcolorbox}

ถ้าหากว่าเรานำสมการ Separation Ansatz ที่ \eqref{eq:simplest_product_ansatz} แทนเข้าไปในสมการที่ \eqref{eq:AIMD_TDSE}
และสมการที่ \eqref{eq:AIMD_Hamiltonian} (หลังจากที่เราทำการคูณทางด้านซ้ายของสมการด้วย  $\langle\Psi|$ และ $\langle\chi|$
และทำให้สอดคล้องตามเงื่อนไขของกฎอนุรักษ์พลังงาน $d\langle H\rangle / d t \equiv 0$ แล้ว) เราจะได้ความสัมพันธ์ต่อไปนี้

\begin{align}
  \label{eq:AIMD_coupled_TDSCF_1}
  i \hbar \frac{\partial \Psi}{\partial t}
   & =
  - \sum_i \frac{\hbar^2}{2 m_{\mathrm{e}}} \nabla_i^2 \Psi
  + \left\{\int d \mathbf{R} \chi^{\star}\left(\mathbf{R}_I ; t\right)
  V_{\mathrm{n}-\mathrm{e}}\left(\mathbf{r}_i,\mathbf{R}_I\right)
  \chi\left(\mathbf{R}_I ; t\right)\right\} \Psi \\
  \label{eq:AIMD_coupled_TDSCF_2}
  i \hbar \frac{\partial \chi}{\partial t}
   & =
  - \sum_I \frac{\hbar^2}{2 M_I} \nabla_I^2 \chi
  + \left\{\int d \mathbf{r} \Psi^{\star}\left(\mathbf{r}_i ; t\right)
  H_{\mathrm{e}}\left(\mathbf{r}_i,\mathbf{R}_I\right)
  \Psi\left(\mathbf{r}_i ; t\right)\right\} \chi
\end{align}

\noindent ซึ่งเซตของสมการที่พัวพันกัน (Coupled Equations) ตามด้านบนนี้เป็นตัวกำหนด Time-Dependent Self-Consistent Field
(TDSCF) ที่ได้มีการเสนอไว้เมื่อนานมาแล้วโดย Paul Dirac ในช่วงปี ค.ศ. 1930

%----------------------------------------
\section{มาเจาะลึก Classical Molecular Dynamics}
%----------------------------------------

ขึ้นตอนต่อไปในการพิสูจน์ Classical Molecular Dynamics ก็คือการประมาณและกำหนดให้นิวเคลียอของอะตอมนั้นเป็นอนุภาคจุด (Point
Particle) ซึ่งเราสามารถทำได้โดยการใช้พิสูจน์ Classical Mechanics ออกมาจาก Quantum Mechanics โดยเราจะเริ่มด้วยการเขียนฟังก์ชันคลื่น
(Wavefunction) ใหม่ ดังนี้

\begin{equation}
  \label{eq:AIMD_corresponding_wfn}
  \chi\left(\mathbf{R}_I ; t\right)
  =
  A\left(\mathbf{R}_I ; t\right) \exp \left[i S\left(\mathbf{R}_I ; t\right) / \hbar\right]
\end{equation}

\noindent โดยเราเขียนในเทอมของ Amplitude Factor $A$ และ Phase $S$ ซึ่งแฟคเตอร์ทั้งสองแฟคเตอร์นี้จะถูกพิจารณาเฉพาะค่าจริง (Real)
เท่านั้น $(A>0)$ และหลังจากที่เราทำการแปลง Nuclear Wavefunction (สมการที่ \eqref{eq:AIMD_coupled_TDSCF_2}) และทำการแยก
Real Part กับ Imaginary Part ออกจากกัน เราจะได้ TDSCF สำหรับนิวเคลียสดังต่อไปนี้

\begin{align}
  \label{eq:AIMD_phase_S}
   & \frac{\partial S}{\partial t}
  + \sum_I \frac{1}{2 M_I}\left(\nabla_I S\right)^2
  + \int d \mathbf{r} \Psi^{\star} H_{\mathrm{e}} \Psi
  =
  \hbar^2 \sum_I \frac{1}{2 M_I} \frac{\nabla_I^2 A}{A} \\
  \label{eq:AIMD_factor_A}
   & \frac{\partial A}{\partial t}
  + \sum_I \frac{1}{M_I}\left(\nabla_I A\right)\left(\nabla_I S\right)
  + \sum_I \frac{1}{2 M_I} A\left(\nabla_I^2 S\right)
  =
  0
\end{align}

\noindent ซึ่งเป็นการเขียนสมการเดิมโดยการใช้ตัวแปรใหม่สองอันก็คือ $A$ และ $S$ และเราเรียกสมการที่ \eqref{eq:AIMD_phase_S} และ
\eqref{eq:AIMD_factor_A} นี้ว่า \enquote{Quantum Fluid Dynamical Representation} ซึ่งเราสามารถสมการทั้งสองอันนี้ไปใช้ในการแก้
Time-Dependent Schr\"{o}dinger Equation นอกจากนี้เรายังสามารถเขียน $A$ ใหม่ได้ให้อยู่ในรูปของ Continuity Equation
ได้โดยการใช้คุณสมบัติ Identification ของ Nuclear Density $|\chi|^2 \equiv A^2$ ซึ่งสามารถคำนวณมาได้จากสมการที่
\eqref{eq:AIMD_corresponding_wfn} โดยสมการ Continuity Equation นี้จะไม่ขึ้นกับ $\hbar$ และยังทำให้มีการอนุรักษ์ Particle
Probability $|\chi|^2$ อีกด้วย

เมื่อเรามีการใช้ Transformation ของโมเมนตัมดังต่อไปนี้มาช่วย

\begin{equation}
  \mathbf{P}_I \equiv \nabla_I S
\end{equation}

\noindent เราจะสามารถเขียนสมการการเคลื่อนที่ของนิวตัน $\dot{\mathbf{P}}_I = -\nabla_I V\left(\mathbf{R}_I\right)$
ได้ดังต่อไปนี้

\begin{align}
  \label{eq:AIMD_Newtonian_1}
  \frac{d \mathbf{P}_I}{d t} & =-\nabla_I \int d \mathbf{r} \Psi^{\star} H_{\mathrm{e}} \Psi      \\
  \label{eq:AIMD_Newtonian_2}
  M_I \ddot{\mathbf{R}}_I(t) & =-\nabla_I \int d \mathbf{r} \Psi^{\star} H_{\mathrm{e}} \Psi      \\
  \label{eq:AIMD_Newtonian_3}
                             & =-\nabla_I V_{\mathrm{e}}^{\mathrm{E}}\left(\mathbf{R}_I(t)\right)
\end{align}

ดังนั้น นิวเคลียสนั้นจะเคลื่อนที่ไปตามหลักการของ Classical Mechanics ท่ามกลาง Effect Potentail $V_{\mathrm{e}}^{\mathrm{E}}$
ซึ่งมาจากอิเล็กตรอน โดย Potential ดังกล่าวนี้เป็นฟังก์ชันของ Nuclear Positions ณ เวลา $t$ ซึ่งได้มาจากการเฉลี่ย
$H_{\mathrm{e}}$ จาก Degrees of Freedom ทั้งหมด เช่น คำนวณค่า Quantum Expectation Value
$\left\langle\Psi\left|H_{\mathrm{e}}\right| \Psi\right\rangle$ ในขณะที่เราบังคับให้ตำแหน่งของนิวเคลียสนั้นถูกตรึง (Fixed)
อยู่กับที่นั่นคือ $\mathbf{R}_I(t)$

อย่างไรก็ตาม เรายังคงมีฟังก์ชันคลื่นของนิวเคลียส (Nuclear Wavefunction) เหลืออยู่ในสมการ TDSCF สำหรับ Degrees of Freedom
ของอิเล็กตรอนและเทอมนี้ควรจะต้องถูกแทนที่ด้วยตำแหน่งของนิวเคลียสเพื่อที่ว่าสมการ TDSCF นั้นจะขึ้นอยู่กับนิวเคลียสเพียงอย่างเดียว
ในกรณีนี้เราจะทำการแทนที่ Nuclear Density $\left|\chi\left(\mathbf{R}_I ; t\right)\right|^2$
ในสมการก่อนหน้านี้โดยมีเงื่อนไขของลิมิตว่า $\hbar \rightarrow 0$ โดยแทนที่ด้วยผลคูณของฟังก์ชันเดลต้า (Delta Functions)
$\prod_I \delta\left(\mathbf{R}_I-\mathbf{R}_I(t)\right)$ ที่มีตำแหน่งจุดกึ่งกลางของฟังก์ชันอยู่ที่ตำแหน่งของนิวเคลียส ณ
ขณะใดขณะหนึ่ง (Instantaneous Positions) $\mathbf{R}_I(t)$ ตามสมการที่ \eqref{eq:AIMD_Newtonian_2}
ซึ่งเราจะได้สมการดังต่อไปนี้ (สำหรับ Position Operator)

\begin{equation}
  \int d \mathbf{R}^{\star}\left(\mathbf{R}_I ; t\right) \mathbf{R}_I \chi\left(\mathbf{R}_I ; t\right)
  \stackrel{\hbar \rightarrow 0}{\longrightarrow}
  \mathbf{R}_I(t)
\end{equation}

โดย Classical Limit อันนี้จะนำไปสู่สมการ Time-Dependent Wave Equation สำหรับอธิบายอิเล็กตรอนดังต่อไปนี้

\begin{align}
  \label{eq:AIMD_TD_wave_electron_1}
  i \hbar \frac{\partial \Psi}{\partial t}
   & = -\sum_i \frac{\hbar^2}{2 m_{\mathrm{e}}} \nabla_i^2 \Psi
  + V_{\mathrm{n}-\mathrm{e}}\left(\mathbf{r}_i,\mathbf{R}_I(t)\right) \Psi \\
  \label{eq:AIMD_TD_wave_electron_2}
   & = H_{\mathrm{e}}\left(\mathbf{r}_i,\mathbf{R}_I(t)\right)
  \Psi\left(\mathbf{r}_i,\mathbf{R}_I ; t\right)
\end{align}

\noindent ซึ่งสมการด้านบนนี้มีความซับซ้อนเพราะว่าเป็นสมการที่มันขึ้นอยู่กับตัวของมันเอง (Self-Consistently) นอกจากนี้แล้ว
$H_{\mathrm{e}}$ และ $\Psi$ นั้นจะขึ้นต่อกันแบบเชิงพารามิเตอร์หรือเรียกว่าอิงพารามิเตอร์ก็ได้ (Parametrically) ตามตำแหน่งของนิวเคลียส
$\mathbf{R}_I(t)$ ที่เวลา $t$ โดยผ่าน $V_{\mathrm{n}-\mathrm{e}}\left(\mathbf{r}_i,\mathbf{R}_I(t)\right)$
นั่นหมายความว่าทั้ง Classical และ Quantum Degress of Freedom นั้นได้ถูกรวมเข้าด้วยกันแล้ว

สำหรับวิธีที่เกี่ยวข้องกับการแก้สมการที่ \eqref{eq:AIMD_Newtonian_2} และ \eqref{eq:AIMD_TD_wave_electron_2} นั้นมีชื่อเรียกว่า
\enquote{Ehrenfest Molecular Dynamics} เพื่อเป็นเกียรติให้กับ Ehrenfest ผู้ที่เป็นคนแรกที่สามารถหาวิธีแก้ปัญหาสำหรับคำถามที่ว่า
\enquote{เราจะสามารถพิสูจน์ Newtonian Classical Dynamics จากสมการคลื่นของ Schr\"{o}dinger ได้อย่างไร?}
ซึ่งนำไปสู่การพัฒนาวิธีการแบบผสม (Hybrid) นั่นก็คือมีเพียงแค่นิวเคลียสเท่านั้นที่ถูกบังคับให้มีพฤติกรรมที่ทำตัวคล้ายกับอนุภาค Classical
Particles ในขณะที่อิเล็กตรอนนั้นยังถูกอธิบายด้วยวิธีทางควอนตัม

ตามที่ได้กล่าวไว้ในตอนต้นของหัวข้อนี้แล้วว่าวิธี MD นั้นมีปัญหาอย่างหนึ่งที่หลีกเลี่ยงไม่ได้ก็คือ Dimensionality Bottleneck ซึ่งจะเพิ่มมากขึ้นตาม
Degrees of Freedom ของนิวเคลียส (จำนวนอะตอม) ซึ่งหนึ่งในวิธีที่เป็นทางออกของปัญหานี้ก็คือการทำการประมาณ Global PES ซึ่งมีสมการคือ

\begin{align}
  \label{eq:global_PES}
  V_{\mathrm{e}}^{\mathrm{E}} \approx V_{\mathrm{e}}^{\mathrm{approx}}\left(\mathbf{R}_I\right)
  = &
  \sum_{I=1}^N v_1\left(\mathbf{R}_I\right)+\sum_{I<J}^N v_2\left(\mathbf{R}_I, \mathbf{R}_J\right) \nonumber \\
    & +\sum_{I<J<K}^N v_3\left(\mathbf{R}_I, \mathbf{R}_J, \mathbf{R}_K\right) + \cdots
\end{align}

\noindent โดยเขียนในรูปของการกระจายของเทอมที่เกิดจาก Contribution แบบ Many-Body (Truncated Expansion) และเราจะทำการแทน
Degrees of Freedom เชิงอิเล็กทรอนิกส์ด้วย Interaction Potentials $\left\{v_n\right\}$ ซึ่งจะทำให้เทอมที่เป็น Degrees of
Freedom นั้นหายไป ดังนั้นสิ่งที่เราจะได้ออกมาก็คือสมการที่เป็นลูกผสมระหว่างปัญหาทางควอนตัมและปัญหาแบบคลาสสิกนั้นจะถูกลดรูปให้เหลือเป็น%
เพียงแค่ปัญหาแบบคลาสสิกเท่านั้น (ปัญหาแบบควอนตัมหายไปแล้ว) ซึ่งจะได้ว่า Classical Molecular Dynamics แบบที่เราต้องการนั้นจะมีหน้าตาคือ

\begin{equation}
  M_I \ddot{\mathbf{R}}_I(t)
  =
  -\nabla_I V_{\mathrm{e}}^{\text{approx }}\left(\mathbf{R}_I(t)\right)
\end{equation}

เราสามารถแบ่งประเภทของ AIMD ได้โดยแบ่งตามวิธีการที่เราใช้ในการรวมการคำนวณโครงสร้างเชิงอิเล็กทรอนิกส์กับการจำลองพลวัตโมเลกุลเข้าด้วยกัน
โดยเราสามารถแบ่งออกได้เป็น 3 วิธี ดังนี้

\begin{enumerate}[topsep=0pt,noitemsep]
  \setlength\itemsep{0.5em}
  \item พลวัตเชิงโมเลกุลแบบเออเรนเฟสต์ (Ehrenfest Molecular Dynamics)

  \item พลวัตเชิงโมเลกุลแบบบอร์น-ออปเพนไฮเมอร์ (Born-Oppenheimer Molecular Dynamics)

  \item พลวัตเชิงโมเลกุลแบบคาร์-พาร์ริเนลโล (Car-Parrinello Molecular Dynamics)
\end{enumerate}

%----------------------------------------
\section{พลวัตเชิงโมเลกุลแบบเออเรนเฟสต์}
%----------------------------------------

ตามที่ได้อธิบายไว้ในหัวข้อที่ผ่านมาว่าปัญหาอย่างหนึ่งของ MD ก็คือ Dimensionality Bottleneck ซึ่งเราสามารถแก้ปัญหานี้ได้โดยการคำนวณประมาณ
Global Potential Energy Surface ตามสมการที่ \eqref{eq:global_PES} หรือทำการลดจำนวนของ Degrees of Freedom นอกจากนี้
ยังมีอีกวิธีหนึ่งที่เราสามารถแก้ปัญหานี้ได้เช่นกันนั่นก็คือทำการแก้สมการ Time-Dependent Self-Consistent Field (TDSCF) โดยการใช้
Classical Nuclei Approxiation เข้ามาช่วย (สมการที่ \eqref{eq:AIMD_Newtonian_2} และ \eqref{eq:AIMD_TD_wave_electron_2})
โดยเราสามารถแก้ชุดสมการดังต่อไปพร้อม ๆ กันเพื่อคำนวณแรงของเออเรนเฟสต์ (Ehrenfest Force)

\begin{align}
  M_I \ddot{\mathbf{R}}_I(t)
   & = -\nabla_I \int d \mathbf{r} \Psi^{\star} H_{\mathrm{e}} \Psi                         \\
   & = -\nabla_I\left\langle\Psi\left|H_{\mathrm{e}}\right| \Psi\right\rangle               \\
   & = -\nabla_I\left\langle H_{\mathrm{e}}\right\rangle                                    \\
  \label{eq:Ehrenfest_coupled_eq_1}
   & = -\nabla_I V_{\mathrm{e}}^{\mathrm{E}}                                                \\
  i \hbar \frac{\partial \Psi}{\partial t}
   & = \left[-\sum_i \frac{\hbar^2}{2 m_{\mathrm{e}}}
  \nabla_i^2+V_{\mathrm{n}-\mathrm{e}}\left(\mathbf{r}_i,\mathbf{R}_I(t)\right)\right] \Psi \\
  \label{eq:Ehrenfest_coupled_eq_2}
   & = H_{\mathrm{e}} \Psi
\end{align}

\noindent แล้วเราก็พบว่าเราไม่จำเป็นที่จะต้องทราบ Potential Energy Surface (PES) ก็สามารถแก้สมการ Time-Dependent Electronic
Schr\"{o}dinger ได้แบบ \enquote{On-The-Fly} (หมายความว่า อยากแก้สมการเมื่อไหร่ก็ได้) ซึ่งทำให้เรานั้นสามารถคำนวณ Ehrenfest
Force จาก $\nabla_I\left\langle H_{\mathrm{e}}\right\rangle$ สำหรับแต่ละคอนฟิกูเรชั่น $\mathbf{R}_I(t)$
ของโมเลกุลที่ได้มาจาก Trajectory ที่จำลองมาจากวิธี Molecular Dynamics ได้ด้วย (แรงชนิดนี้มีชื่อเรียกอีกชื่อว่า \enquote{Hellmann-Feynman
  Forces}

นอกจากนี้แล้ว ยังมีสมการของ Equations of Motion ที่อยู่ในรูปของ Adiabatic Basis และ Time-Dependent Expansion Coefficients
อีกด้วย ซึ่งมีหน้าตาดังนี้

\begin{align}
  M_I \ddot{\mathbf{R}}_I(t) &
  =
  -\sum_k\left|c_k(t)\right|^2 \nabla_I E_k-\sum_{k, l} c_k^{\star} c_l\left(E_k-E_l\right) \mathbf{d}_I^{k l} \\
  i \hbar \dot{c}_k(t)
                             & = c_k(t) E_k-i \hbar \sum_{I, l} c_l(t) \dot{\mathbf{R}}_I \mathbf{d}_I^{k l}
\end{align}

\noindent ซึ่งมี Coupling Term ดังนี้

\begin{equation}
  \mathbf{d}_I^{k l}\left(\mathbf{R}_I(t)\right)
  =
  \int d \mathbf{r} \Psi_k^{\star} \nabla_I \Psi_l
\end{equation}

\noindent แล้วก็มี Property $\mathbf{d}_I^{k k} \equiv \mathbf{0}$

ดังนั้น เราอาจจะมองว่าวิธีการของ Ehrenfest นั้นก็คือเป็นการรวม Non-Adiabatic Transitions ระหว่าง Electronic States ที่แตกต่างกัน
นั่นคือ $\Psi_k$ และ $\Psi_l$ โดยรวมเข้ามาไว้ใน Framework ของ Mean-Field (TDSCF) Approximation นั่นเอง
นอกจากนี้แล้วเรายังสามารถกำหนดเงื่อนไข (Restriction) สำหรับ Electronic State แต่ละอันได้อีกด้วย (ซึ่งกรณีส่วนใหญ่นั่นจะเป็นการอธิบาย
$\Psi_0$ ที่สภาวะพื้น) ซึ่งก็จะทำให้เราได้สมการที่เป็นสำหรับกรณีพิเศษของสมการที่ \eqref{eq:Ehrenfest_coupled_eq_1} และ
\eqref{eq:Ehrenfest_coupled_eq_2} ดังนี้

\begin{align}
  \label{eq:Ehrenfest_EoQ_1}
  M_I \ddot{\mathbf{R}}_I(t)
   & =
  -\nabla_I\left\langle\Psi_0\left|H_{\mathrm{e}}\right| \Psi_0\right\rangle \\
  \label{eq:Ehrenfest_EoQ_2}
  i \hbar \frac{\partial \Psi_0}{\partial t}
   & = H_{\mathrm{e}} \Psi_0
\end{align}

\noindent โดยที่ $H_{\mathrm{e}}$ คือ Time-Dependent Hamiltonian ของ Nuclear Coordinates
$(\mathbf{R}_I(t))$

Ehrenfest Molecular Dynamics (MD) นั้นถือได้ว่าเป็นวิธี \enquote{On-The-Fly} MD ที่เก่าที่สุดและถูกใช้ในการจำลองระบบที่มีจำนวน
Degrees of Freedom น้อย ๆ ดังนั้นเราจึงมักไม่ค่อยเห็นงานวิจัยที่นำ Ehrenfest MD มาใช้ในการศึกษาระบบที่มี Degrees of Freedom เยอะ ๆ
เช่น Condensed Matter

%----------------------------------------
\section{พลวัตเชิงโมเลกุลแบบบอร์น-ออปเพนไฮเมอร์}
%----------------------------------------

อีกหนึ่งวิธีที่เราสามารถใช้ในการรวมการคำนวณ Electronic Structure เข้ากับ Molecular Dynamics ได้นั้นก็คือการแก้สมการของ Electronic
Structure ตรง ๆ (แบบ Static) ในแต่ละ Step ของการจำลอง MD โดยการใช้ตำแหน่งของอะตอมในโมเลกุลซึ่งมีตำแหน่งที่แน่นอน ดังนั้น
แทนที่เราจะต้องแก้ปัญหาแบบ Time-Dependent นั้นก็จะกลายเป็นว่าเราแก้ปัญหาแบบ Time-Independent แทน พูดง่าย ๆ ก็คือเราคำนวณแรง
(Force) ที่กระทำต่ออะตอมแต่ละอะตอมในโมเลกุลในแต่ละ Step เพื่อใช้ในการ Propagation ของคอนฟิกูเรชั่นของโมเลกุลใน Step ต่อ ๆ ไป
แน่นอนว่าสมการที่เราจะต้องแก้นั้นก็คือ Time-Independent Schr\"{o}dinger Equation ดังนั้นเราจึงสรุปได้ว่าวิธีนี้นั้นก็เปรียบเสมือนกับ
Time-Dependent Electronic Structure ของการเคลื่อนที่ของโมเลกุล (Nuclear Motion) ซึ่งจะไม่เหมือนกับกรณีของ Ehrenfest MD
ซึ่งจะมีความ Intrinsic มากกว่า โดยเราเรียกวิธีการนี้ว่า Born-Oppenheimer Molecular Dynamics (BOMD) นั่นเอง ซึ่งมีสมการหลักดังต่อไปนี้

\begin{align}
  \label{eq:BOMD_EoQ_1}
  M_I \ddot{\mathbf{R}}_I(t)
   & =
  -\nabla_I \min _{\Psi_0}\left\{\left\langle\Psi_0\left| H_{\mathrm{e}}\right| \Psi_0\right\rangle\right\} \\
  \label{eq:BOMD_EoQ_2}
  E_0 \Psi_0
   & =
  H_{\mathrm{e}} \Psi_0
\end{align}

\noindent โดยสมการด้านบนนี้สำหรับกรณีสถานะพื้น (Ground State) แล้วก็สิ่งที่ BOMD นั้นแตกต่างจาก Ehrenfest MD อย่างเห็นได้ชัดนั่นก็คือ
Nuclear Equation of Motion ซึ่ง BOMD นั้นจะมีเงื่อนไขว่าค่าของ $\left\langle H_{\mathrm{e}}\right\rangle$
นั้นจะต้องมีค่าที่ต่ำที่สุดตามสมการที่ \eqref{eq:BOMD_EoQ_1} แต่สำหรับกรณีของ Ehrenfest MD นั้นจะตรงข้ามกันนั่นก็คือฟังก์ชันคลื่น
(Wavefunction) ที่เป็นเทอมที่ทำ Minimize $\left\langle H_{\mathrm{e}}\right\rangle$ นั้นยังคงมีค่าเท่าเดิมเมื่อเทียบกับ
Motion ของนิวเคลียส (อะตอมในโมเลกุล) ตามสมการที่ \eqref{eq:Ehrenfest_EoQ_1}

ลำดับต่อไปก็คือส่วนขยายของสมการการเคลื่อนที่ของ BOMD นั่นก็คือการทำให้ BOMD นั้นสามารถใช้งานได้กับโมเลกุลที่อยู่ในสถานะกระตุ้น (Excited
Electronic State) หรือ $\Psi_k$ ซึ่งมีชื่อเรียกแบบเฉพาะอีกชื่อว่า \enquote{Adiabatic Molecular Dynamics} (ถึงแม้ว่าจะไม่ควรเรียกก็ตาม)

นอกจากนี้เราพบว่าการที่เรามี Equation of Motion สำหรับ BOMD ที่สามารถใช้ในการอธิบายกรณีพิเศษของ Effective One-Particle Hamiltonian
นั้นก็มีประโยชน์อย่างมากเช่นกัน เพราะว่าเราสามารถที่จะใช้ Hartree-Fock Approximation ที่ถูกกำหนดให้เป็น Variational Minimum
สำหรับค่าของ Expectation Value ของพลังงาน $(\left\langle\Psi_0\left| H_{\mathrm{e}}\right| \Psi_0\right\rangle)$
โดยที่เรามีการกำหนดให้ Single Slater Determinant $\Psi_0=$ $\operatorname{det}\left\{\psi_i\right\}$ ซึ่งเปลี่ยนไปตาม
Constraint หรือเงื่อนไขที่ว่า One-Particle Orbitals $\psi_i$ นั้นจะต้องมีความเป็น Orthonormal
$\left\langle\psi_i \mid \psi_j\right\rangle=\delta_{i j}$

สำหรับ Constraint Minimization ของพลังงานของโมเลกุลโดยเทียบกับออร์บิทัลนั้นมีดังต่อไปนี้

\begin{equation}
  \label{eq:BOMD_min_constraint}
  \left.\min _{\left\{\psi_i\right\}}\left\{\left\langle\Psi_0\left|
  H_{\mathrm{e}}\right| \Psi_0\right\rangle\right\}\right
  |_{\left\{\left\langle\psi_i \mid \psi_j\right\rangle=\delta_{i j}\right\}}
\end{equation}

\noindent ซึ่งสามารถเขียนใหม่ให้เป็น Lagrange's Formalism ได้ดังนี้

\begin{equation}
  \mathcal{L}
  =
  - \left\langle\Psi_0\left| H_{\mathrm{e}}\right| \Psi_0\right\rangle
  + \sum_{i, j} \Lambda_{i j}\left(\left\langle\psi_i \mid \psi_j\right\rangle-\delta_{i j}\right)
\end{equation}

\noindent โดยที่เรามีเทอม $\Lambda_{i j}$ ซึ่งเป็น Lagrangian Multipliers แล้วก็การแปรผันแบบที่ไม่มีข้อบังคับ (Unconstrained
Variation) ของ Lagrangian อันนี้เมื่อเทียบกับออร์บิทัลนั้นมีค่าเป็น

\begin{equation}
  \frac{\delta \mathcal{L}}{\delta \psi_i^{\star}} \stackrel{!}{=} 0
\end{equation}

\noindent ซึ่งนำไปสู่สมการ Hartree-Fock ที่เราทราบกันดี นั่นคือ

\begin{equation}
  H_{\mathrm{e}}^{\mathrm{HF}} \psi_i=\sum_j \Lambda_{i j} \psi_j
\end{equation}

\noindent ตามที่เราทราบกันนั่นก็คือ Diagonal Canonical Form $ H_{\mathrm{e}}^{\mathrm{HF}} \psi_i=\epsilon_i \psi_i$
นั้นจะถูกคำนวณออกมาหลังจากที่เราทำ Unitary Transformation แล้ว ($H_{\mathrm{e}}^{\mathrm{HF}}$ คือ Effective
One-Particle Hamiltonian) สำหรับสมการการเคลื่อนที่ (Equations of Motion) ที่เกี่ยวเนื่องกับสมการที่ \eqref{eq:BOMD_EoQ_1} และ
\eqref{eq:BOMD_EoQ_2} มีดังนี้

\begin{align}
  \label{eq:BOMD_EoQ_HF_1}
  M_I \ddot{\mathbf{R}}_I(t)
   & =
  -\nabla_I \min _{\left\{\psi_i\right\}}\left\{\left\langle\Psi_0\left|
  H_{\mathrm{e}}^{\mathrm{HF}}\right| \Psi_0\right\rangle\right\} \\
  \label{eq:BOMD_EoQ_HF_2}
  0
   & =
  - H_{\mathrm{e}}^{\mathrm{HF}} \psi_i+\sum_j \Lambda_{i j} \psi_j
\end{align}

\noindent สำหรับกรณีของ Hartree-Fock

ถ้าหากว่าเป็นกรณีอื่นที่ไม่ใช่ Hartree-Fock เช่น กรณีของ Hohenberg-Kohn-Sham Density Functional Theory เราก็สามารถใช้สมการที่
\eqref{eq:BOMD_EoQ_HF_1} และ \eqref{eq:BOMD_EoQ_HF_2} ได้เหมือนกัน แต่สิ่งที่จะไม่เหมือนกันนั่นก็คือ $H_{\mathrm{e}}^{\mathrm{HF}}$
นั้นจะต้องถูกแทนที่ด้วย Kohn-Sham Effective One-Particle Hamiltonian $H_{\mathrm{e}}^{\mathrm{KS}}$ แล้วก็แทนที่เราจะต้องทำ
Diagonalization ของ One-Particle Hamiltonian เราก็สามารถที่จะใช้วิธีการที่คล้าย ๆ กันได้นั่นก็คือการทำ Constraint Minimization
ตามสมการที่ \eqref{eq:BOMD_min_constraint} โดยใช้เทคนิค Nonlinear Optimization

สำหรับการนำ BOMD ไปใช้งานนั้นในช่วงแรก ๆ BOMD มักจะถูกนำมาใช้ในการคำนวณร่วมกับวิธี Semiempirical แต่ว่าตั้งแต่ช่วงปี ค.ศ. 2000
เป็นต้นมานั้นก็ได้มีการนำ \textit{ab initio} มา Implement\footnote{Implement คือการทำให้สิ่ง ๆ นั้นเกิดขึ้น ถ้าเป็นในบริบทของ%
การพัฒนาโปรแกรมก็คือการเขียนโปรแกรมของทฤษฎีนั้น ๆ} รวมเข้าไปในวิธี BOMD ซึ่งทำให้ได้รับความนิยมเรื่อยมาจนทำให้ BOMD
นั้นได้รับความนิยมเป็นอย่างมาก โดยหนึ่งในจุดเปลี่ยนผ่านที่สำคัญของ BOMD ก็คือนำ Density Functional Theory (DFT) เข้ามาผสมกับ BOMD
ซึ่งเป็น Framework ที่มีความสิ้นเปลืองที่ไม่สูงมากแต่ว่าให้ผลการคำนวณที่แม่นยำมาก

%----------------------------------------
\section{พลวัตเชิงโมเลกุลแบบคาร์-พาร์ริเนลโล}
%----------------------------------------

Car กับ Parrinello ได้เสนอวิธีอีกแบบหนึ่งที่ช่วยให้เราสามารถลดความสิ้นเปลืองในการคำนวณ Molecular Dynamics ซึ่งได้รวม Electronic
Single State (การเคลื่อนที่ของอิเล็กตรอน) เข้าไว้ด้วย โดยเราเรียกวิธีนี้ว่า Car-Parrinello Molecular Dynamics (CPMD) ซึ่งถือว่าเป็นวิธีที่
3 ของ \textit{ab initio} Molecular Dynamics

ถ้าสรุปง่าย ๆ ก็คือว่าวิธี CPMD นั้นเป็นการรวมเอาข้อดีของวิธี Ehrenfest MD กับ BOMD เข้าไว้ด้วยกัน ซึ่งในวิธี Ehrenfest MD นั้น Time Scale
และ Time Step นั้นจะถูกกำหนดด้วย Dynamics ของอิเล็กตรอน แล้วก็เนื่องจากว่า Motion ของอิเล็กตรอนนั้นเร็วกว่า Motion ของนิวเคลียสเยอะมาก ๆ
ทำให้ขนาดของ Time Step ที่มากที่สุดที่จะเป็นไปได้นั้นจะต้องสอดคล้องตาม Motion ของอิเล็กตรอนเพื่อที่เราจะสามารถอินทิเกรตหรือแก้สมการ
Equation of Motion ได้ แต่ว่าวิธี BOMD นั้นจะต้องกันข้ามกับวิธี Ehrenfest MD โดยสิ้นเชิงก็คือว่า BOMD นั้นจะไม่มีการพิจารณา Dynamics
ของอิเล็กตรอนและไม่นำเอามาคิดรวมด้วย นั่นหมายความว่าในวิธี BOMD นั้นเราจะทำการอินทิเกรตและแก้สมการ Equation of Motion โดยใช้
Time Scale ที่อ้างอิงตาม Motion ของนิวเคลียส อย่างไรก็ตาม นั่นหมายความว่าสำหรับวิธี Ehrenfest MD นั้นเราไม่จำเป็นต้องแก้ปัญหาเชิง
Electronic Structure เพราะว่าเราสามารถที่จะทำการ Propagate ฟังก์ชันคลื่นได้โดยการนำ Hamiltonian มากระทำกับฟังก์ชันคลื่นเริ่มต้น
แต่ว่าสำหรับวิธี BOMD นั้นเราจะยังคงต้องแก้ปัญหา Electronic Structure โดยการแก้สมการหาคำตอบแบบ Self-Consistently ในแต่ละ Step
ของการคำนวณ MD

อย่างไรก็ตาม ถ้าหากว่าเรามานั่งพิจารณาตัวทฤษฎีและอัลกอริทึมอย่างละเอียดแล้ว เราอาจจะพอตั้งข้อสังเกตได้ว่าถ้าหากว่าเราต้องการที่จะพัฒนาวิธีการที่เป็น
\enquote{The Best of All Worlds Method} แล้วล่ะก็ วิธีการนั้นก็ควรที่จะต้องเป็นไปตามเงื่อนไขต่อไปนี้

\begin{enumerate}[topsep=0pt,noitemsep]
  \setlength\itemsep{0.5em}
  \item สามารถอินทิเกรตสมการ Equation of Motion ตาม Time Scale ที่ถูกกำหนดด้วย Nuclear Motion (ตำแหน่งของนิวเคลียส)

  \item ในขณะเดียวกันนั้นก็ควรที่จะสามารถคำนวณ Dynamics ของอิเล็กตรอนให้ Smooth (Time-Evolution) มากที่สุดเท่าที่จะเป็นไปได้
\end{enumerate}

\noindent ซึ่งข้อ 2 นั้นช่วยให้เราสามารถแก้ปัญหา Electronic Structure ได้โดยที่ไม่ต้องคำนวณ Diagonalization หรือทำ Minimization
เพื่อนำคำตอบไปใช้ใน Step ต่อไปในระหว่างที่เราทำการคำนวณ MD และนี่จึงทำให้ CPMD นั้นเป็นวิธีที่มีประสิทธิภาพมาก ๆ เพราะว่าสอดคล้องกับทั้งสองข้อ

ไอเดียของวิธี CPMD นั้นเป็นการใช้ Adiabatic Time-Scale Separation (การแบ่งตาม Time-Scale) เพื่อแบ่ง Motion ของนิวเคลียสที่เคลื่อนที่ช้า
และอิเล็กตรอนที่เคลื่อนที่เร็วโดยการแปลง Quantum Adiabatic Time-Scale ให้อยู่ในรูปของ Classical Adiabatic Energy-Scale แทน
โดยในกรณีของ Classical Mechanics นั้นเราจะคำนวณแรง (Force) ได้จากอนุพันธ์ของ Lagrangian เทียบกับตำแหน่งของนิวเคลียส
ซึ่งนี่เป็นการบอกใบ้กับเราอ้อม ๆ ว่าอนุพันธ์เชิงฟังก์ชัน (Functional Derivative) เทียบกับออร์บิทัลนั้นก็คือแรงที่กระทำต่อออร์บิทัลนั่นเอง
นอกจากนี้เราจะต้องมีการกำหนด Constraint สำหรับออร์บิทัลด้วย เช่น ออร์บิทัลนั้นก็ควรที่จะมีความเป็น Orthonormality

ในเปเปอร์ต้นฉบับของ Car และ Parrinello นั้นได้มีการเสนอ Lagrangian ไว้ดังนี้

\begin{equation}
  \mathcal{L}_{\mathrm{CP}}
  =
  \underbrace{\sum_I \frac{1}{2} M_I \dot{\mathbf{R}}_I^2
    +\sum_i \frac{1}{2} \mu_i\left\langle\dot{\psi}_i \mid \dot{\psi}_i\right\rangle}_{\text{พลังงานจลน์}}
  -\underbrace{\left\langle\Psi_0\left| H_{\mathrm{e}}\right| \Psi_0\right\rangle}_{\text{พลังงานศักย์}}
  +\underbrace{\text{ Constraints }}_{\text{Orthonormality }}
\end{equation}

\noindent และเราก็สามารถเขียน Newtonian Equation of Motion ได้จากชุดสมการ Euler-Lagrange ดังนี้


\begin{align}
  \frac{d}{d t} \frac{\partial \mathcal{L}}{\partial \dot{\mathbf{R}}_I}
   & =
  \frac{\partial \mathcal{L}}{\partial \mathbf{R}_I} \\
  \frac{d}{d t} \frac{\delta \mathcal{L}}{\delta \dot{\psi}_i^{\star}}
   & =
  \frac{\delta \mathcal{L}}{\delta \psi_i^{\star}}
\end{align}

\noindent โดยที่ $\psi_i^{\star}=\left\langle\psi_i\right|$

สมการ Equations of Motion ของ Car-Parrinello นั้นมีหน้าตาดังต่อไปนี้


\begin{align}
  M_I \ddot{\mathbf{R}}_I(t)
   & =
  -\frac{\partial}{\partial \mathbf{R}_I}\left\langle\Psi_0\left| H_{\mathrm{e}}\right| \Psi_0\right\rangle
  +\frac{\partial}{\partial \mathbf{R}_I}\{\text{ constraints }\} \\
  \mu_i \ddot{\psi}_i(t)
   & =
  <-\frac{\delta}{\delta \psi_i^{\star}}\left\langle\Psi_0\left| H_{\mathrm{e}}\right| \Psi_0\right\rangle
  +\frac{\delta}{\delta \psi_i^{\star}}\{\text{ constraints }\}
\end{align}

\noindent โดยที่ $\mu_i(=\mu)$ คือ \enquote{Fictitious Masses} หรือมวลแบบปลอม ๆ ที่เป็นตัวกำหนด Degrees of Freedom
ของออร์บิทัล แล้วก็มี Mass Parameter $\mu$ ที่มีหน่วยเป็นพลังงานคูณกับเวลายกกำลังสอง ส่วนเทอมที่เขียนว่าเป็น Constraint ในสมการด้านบนนั้น
จริง ๆ แล้วก็คือ Constraint Force ใน Equations of Motion ซึ่งมีหน้าตาประมาณนี้

\begin{equation}
  \text{ constraints }
  =
  \text{ constraints }\left(\left\{\psi_i\right\},\left\{\mathbf{R}_I\right\}\right)
\end{equation}

\noindent ซึ่งอาจจะเป็นฟังก์ชันของออร์บิทัล $\left\{\psi_i\right\}$ และตำแหน่งของนิวเคลียร์ $\left\{\mathbf{R}_I\right\}$ ก็ได้

%----------------------------------------
\section{แล้ว Hellmann-Feynman Force ล่ะ?}
%----------------------------------------

ส่วนผสมที่สำคัญมาก ๆ ของวิธีทาง Molecular Dynamics ทุกวิธีนั้นก็คือแรง (Force) ซึ่งวิธีการคำนวณแรงที่มีประสิทธิภาพนั้นคือสิ่งที่เราต้องการ
โดยเราที่เราสนใจก็คือแรงที่กระทำต่อนิวเคลียสของอะตอมแต่ละอะตอมในโมเลกุล โดยเราสามารถคำนวณแรงได้โดยการคำนวณอนุพันธ์ดังต่อไปนี้ด้วยวิธี
Numerical Method (การประมาณเชิงตัวเอง)

\begin{equation}
  \label{eq:Force_numerical}
  \mathbf{F}_I
  =
  -\nabla_I\left\langle\Psi_0\left| H_{\mathrm{e}}\right| \Psi_0\right\rangle
\end{equation}

\noindent โดยเขียนในเทอมของการใช้การประมาณค่าด้วยผลต่างแบบมีขอบเขต (Finite Difference Approximation) ของพลังงานรวม
(Total Electronic Energy) ซึ่งการคำนวณแรงตามสมการที่ \eqref{eq:Force_numerical} นั้นใช้เวลานานและให้ผลที่ไม่ถูกต้อง
คำถามที่ตามมาคือ \enquote{จะเกิดอะไรขึ้นถ้าหากว่าเราสามารถคำนวณ Gradient ของพลังงานรวม (แรง) ได้ด้วยวิธีเชิงวิเคราะห์ (Analytically)}
โดยนอกเหนือจากอนุพันธ์ของ Hamiltonian แล้ว

\begin{align}
  \nabla_I\left\langle\Psi_0\left| H_{\mathrm{e}}\right| \Psi_0\right\rangle
  = & \left\langle\Psi_0\left|\nabla_I  H_{\mathrm{e}}\right| \Psi_0\right\rangle  \\
    & +\left\langle\nabla_I \Psi_0\left| H_{\mathrm{e}}\right| \Psi_0\right\rangle
  + \left\langle\Psi_0\left| H_{\mathrm{e}}\right| \nabla_I \Psi_0\right\rangle
\end{align}

\noindent ก็ยังมี Contribution ที่เกิดจาก Variation ของฟังก์ชันคลื่น (Wavefunction) $\sim \nabla_I \Psi_0$ ด้วย
ซึ่งเราค่อนข้างโชคดีเพราะว่า Contribution ที่ว่านั้นจะหายไป (Vanish) ถ้าหากว่าฟังก์ชันคลื่นนั้นเป็น Eigenfunction ของ Hamiltonian

\begin{equation}
  \label{eq:Force_HFT}
  \mathbf{F}_I^{\mathrm{HFT}}
  =
  -\left\langle\Psi_0\left|\nabla_I  H_{\mathrm{e}}\right| \Psi_0\right\rangle
\end{equation}

\noindent ซึ่งเราเรียกแรงตามสมการที่ \eqref{eq:Force_HFT} นี้ว่าแรงของ Hellmann-Feynman Theorem (HFT) ซึ่งเป็นแรงที่เราสามารถ%
คำนวณได้จาก Variational Favefunctions เช่น Hartree-Fock Wavefunction โดยมีข้อแม้ว่าฟังก์ชันคลื่นอันนั้นจะต้องเกิดขึ้นจากการใช้
Complete Basis Sets (CBS) เท่านั้น ถ้าหากว่าไม่ใช่ CBS เราจะต้องทำการเพิ่มเทอมพิเศษเข้าไป

เราลองมาดูตัวอย่างที่เป็นการใช้ Slater Determinant $\Psi_0=\operatorname{det}\left\{\psi_i\right\}$ ของออร์บิทัล $\psi_i$
ซึ่งสามารถเขียนได้ตามสมการดังต่อไปนี้

\begin{equation}
  \label{eq:One_Particle_Orbitals}
  \psi_i
  =
  \sum_\nu c_{i \nu} f_\nu\left(\mathbf{r} ;\left\{\mathbf{R}_I\right\}\right)
\end{equation}

\noindent ซึ่งเขียนในรูปของผลรวมเชิงเส้นของฟังก์ชันเบสิส (Linear Combination of Basis Functions) $\left\{f_\nu\right\}$
ซึ่งจะถูกใช้ร่วมกับ Effective One-Particle Hamiltonian เช่น Hamiltonian ในวิธี Hartree-Fock หรือวิธี Kohn-Sham โดยที่ Basis
Functions นั้นอาจจะขึ้นอยู่กับตำแหน่งของนิวเคลียสเพียงอย่างเดียว ในขณะที่ Expansion Coefficients จะเป็นตัวที่กำหนดความแตกต่างที่บอกว่า
Basis Functions แต่ละฟังก์ชันนั้นต่างกันอย่างไร นั่นหมายความว่าเราจะมีแรงสองแบบที่สามารถรวมกันได้ ดังนี้

\begin{equation}
  \nabla_I \psi_i
  =
  \sum_\nu\left(\nabla_I c_{i \nu}\right) f_\nu\left(\mathbf{r} ;\left\{\mathbf{R}_I\right\}\right)
  + \sum_\nu c_{i \nu}\left(\nabla_I f_\nu\left(\mathbf{r} ;\left\{\mathbf{R}_I\right\}\right)\right)
\end{equation}

\noindent ซึ่งจะเป็นแรงที่นอกเหนือจากแรง Hellmann-Feynman

ถ้าหากว่าเราใช้การกระจายแบบเชิงเส้น (Linear Expansion) ตามสมการที่ \eqref{eq:One_Particle_Orbitals} เราจะสามารถเขียนแรงที่มี
Contribution ที่มาจาก Nuclear Gradient ของฟังก์ชันคลื่นได้ โดยเราจะแบ่งออกได้เป็น 2 เทอม

\noindent \textbf{แรงที่ได้จาก Nuclear Gradiant ของฟังก์ชันคลื่น เทอมที่ 1}

เทอมแรกก็คือ Incomplete-Basis-Set Correction (IBS) ซึ่งเทอมนี้จะมีประโยชน์ในทฤษฎี Solid State และแรงชนิดนี้ก็ยังสอดคล้องกับ
Wavefunction Force อีกด้วย (มีชื่อเรียกอีกชื่อว่า Pulay Force) ซึ่งสมการของแรง IBS นี้จะประกอบไปด้วย Nuclear Gradient ของ
Basis Functions และ Effective One-Particle Hamiltonian ดังนี้

\begin{equation}
  \mathbf{F}_I^{\mathrm{IBS}}
  =
  - \sum_{i \nu \mu}\left(\left\langle\nabla_I f_\nu\left| H_{\mathrm{e}}^{\mathrm{NSC}}-\epsilon_i\right| f_\mu\right\rangle
  + \left\langle f_\nu\left| H_{\mathrm{e}}^{\mathrm{NSC}}-\epsilon_i\right| \nabla f_\mu\right\rangle\right)
\end{equation}

\noindent \textbf{แรงที่ได้จาก Nuclear Gradiant ของฟังก์ชันคลื่น เทอมที่ 2}

สำหรับแรงที่เกิดมาจาก Nuclear Gradient ของฟังก์ชันคลื่นอีกแรงมีชื่อว่า Non-Self-Consistency Correction (NSC) ซึ่งมีสมการดังนี้

\begin{equation}
  \mathbf{F}_I^{\mathrm{NSC}}
  =
  - \int d \mathbf{r}\left(\nabla_I n\right)\left(V^{\mathrm{SCF}}-V^{\mathrm{NSC}}\right)
\end{equation}

\noindent อธิบายง่าย ๆ ก็คือแรง NSC นี้จะถูกกำหนดด้วยผลต่างระหว่าง Self-Consistent (\enquote{Exact}) Potential หรือสนาม
(Field) $V^{\mathrm{SCF}}$ และ Non-Self-Consistent Counterpart $V^{\mathrm{NSC}}$ ซึ่งก็จะเกี่ยวเนื่องกับ
$H_{\mathrm{e}}^{\mathrm{NSC}} ; n(\mathbf{r})$ ซึ่งก็คือความหนาแน่นประจุ (Charge Density) นั่นเอง

โดยสรุปแล้ว ผลรวมของแรงทั้งหมดที่จำเป็นสำหรับการจำลอง \textins{ab initio} Molecular Dynamics นั้นมีดังนี้

\begin{equation}
  \mathbf{F}_I
  =
  \mathbf{F}_I^{\mathrm{HFT}}
  + \mathbf{F}_I^{\mathrm{IBS}}
  + \mathbf{F}_I^{\mathrm{NSC}}
\end{equation}

\noindent ถ้าหากว่าเราสนใจกรณีที่เราจะต้องคำนวณแรงตามสมการด้านบนนี้ด้วยวิธี Self-Consistency (ซึ่งเราไม่มีทางที่จะใช้ Numerical
Method ได้อย่างแน่นอน) เราพบว่าแรง $\mathbf{F}_I^{\mathrm{NSC}}$ นั้นจะหายไปและ $ H_{\mathrm{e}}^{\mathrm{SCF}}$
ก็จะถูกคำนวณเพื่อใช้ในการคำนวณแรง $\mathbf{F}_I^{\mathrm{IBS}}$ ต่อไป

%----------------------------------------
\section{การสุ่มตัวอย่างแบบมีประสิทธิภาพ}
\idxth{การสุ่มตัวอย่างแบบมีประสิทธิภาพ}
\idxen{Enhanced Sampling}
%----------------------------------------

การสุ่มตัวอย่างแบบมีประสิทธิภาพ (Enhanced Sampling) เป็นเทคนิคที่ถูกพัฒนาขึ้นมาเพื่อแก้ปัญหาของการจำลอง MD แบบดั้งเดิมที่ใช้เวลานานมาก 
(Time Consuming) ในการศึกษาระบบเคมีสักระบบหนึ่ง นั่นจึงทำให้วิธีการจำลอง MD นั้นสามารถจำลองระบบได้ใน Time Scale ที่ระยะสั้นมาก ๆ 
เนื่องจากว่าเราจำเป็นที่จะต้องใช้ Time Step ที่สั้น (ได้เพียงแค่ไม่กี่ Femtoseconds เท่านั้นเอง) ดังนั้นจึงเป็นการยากที่จะใช้วิธี MD 
ในการจำลองปรากฏการณ์ทางเคมีของระบบที่เกิดขึ้นในช่วงระยะเวลา Time Scale ที่นานกว่า เช่น ในระดับ Millisecond 

ในการเพิ่มประสิทธิภาพหรือความเร็วในการจำลองของ MD เพื่อให้เราสามารถมองเห็นปรากฏการณ์บางอย่างของระบบที่เราศึกษาได้ง่ายขึ้น 
เราสามารถทำได้โดยการใช้เทคนิคที่สามารถค้นหา Metastable State ของระบบของเราใน Energy Landscape ได้ง่ายขึ้น ซึ่งสิ่งที่เป็นตัวคั่นระหว่าง 
Metastable State เหล่านี้ก็คือพลังงานจลน์นั่นเอง ดังนั้นเราสามารถก้าวข้าม Barrier อันนี้ไปได้โดยการปรับเปลี่ยนระบบของเราโดยผ่านตัวแปรบางอย่าง 
ซึ่งตัวแปรหรือพารามิเตอร์ที่ว่านั้นก็คือตัวที่กำหนด Probability ในการ Identify ระบบของเรานั่นเอง สำหรับเทคนิค Enhanced Sampling 
ที่เราต้องกำหนด Parameters ที่สอดคล้องกับระบบของเราขึ้นมานั้นจะเรียกว่า Parameters-based ซึ่งมีอยู่ 2 เทคนิคหลัก ๆ ที่ได้รับความนิยม 
คือ Umbrella Sampling (US) และ Metadynamics โดย US นั้นเทคนิคที่จะมีการใส่ Bias แบบคงที่เข้าไปให้กับระบบ ส่วน Metadynamics 
นั้นจะเป็นการใส่ Bias ที่ไม่คงที่ (ขึ้นกับเวลาหรือ Time-Dependent) ให้กับระบบแทน 

สำหรับในหัวข้อนี้ผมจะขออธิบายเพียงแค่เทคนิคเมตาไดนามิกส์ (Metadynamics)

%----------------------------------------
\subsection{เทคนิคเมตาไดนามิกส์}
\idxth{เมตาไดนามิกส์}
\idxen{Metadynamics}
%----------------------------------------

เมตาไดนามิกส์ (Metadynamics) เป็นหนึ่งในวิธีการ Enhanced Sampling ซึ่งอาศัยแนวคิดของการเติมพลังงานเข้าไปให้กับระบบเรื่อย ๆ
(History-Dependent Potential) ซึ่งพลังงานที่ใส่เข้าไปนั้นจะอยู่ในรูปของฟังก์ชัน Gaussian และเราจะใส่พลังงาน Bias Potential
เข้าไปเรื่อย ๆ ในระหว่างการจำลองด้วยวิธี MD โดยสมการของ Metadynamics Potential (Bias) นั้นจะเขียนโดยให้อยู่ในรูปของผลรวมของ
Gaussian Function ดังนี้

\begin{equation}
  V_{\text{bias }}(\vec{\boldsymbol{\xi}},t)
  =
  \sum_{ k \tau < t} W(k \tau)
  \exp\left( -\sum_{i=1}^{d} \frac{(\boldsymbol{\xi}_i - \boldsymbol{\xi}_i^{(0)}(k \tau))^2}{2\sigma_i^2} \right)
\end{equation}

\noindent โดยที่ $\boldsymbol{\xi} = \{\boldsymbol{\xi}_{1}, \boldsymbol{\xi}_{2}, \dots\}$ คือ Collective Variables
(CV) ซึ่งเป็นพารามิเตอร์ที่ผู้ใช้งาน Metadynamics นั้นจะต้องกำหนดเอง โดย $\boldsymbol{\xi}$ นั้นจะเป็นตัวกำหนด Sampling Direction
และ Reaction Coordinates ที่ Bias Potential นั้นจะถูกใส่เข้าไป

เมื่อเราทำการจำลอง MD พร้อมกับการ Sampling ด้วยวิธี Metadynamics เราจะได้สมการ Equation of Motion ที่มีการรวมแรงจาก MD
และแรงจาก Metadynamics เข้าด้วยกัน ดังนี้

\begin{align}
  M_i \frac{d^2 \mathbf{r}_i}{d t^2}
   & =
  \mathbf{F}_{\text{MD }, i}\left(\mathbf{r}_i\right)-\mathbf{F}_{\text{bias }, i}\left(\mathbf{r}_i\right) \\
   & =
  -\frac{\partial V(\mathbf{R})}{\partial \mathbf{r}_i}
  -\frac{\partial V_{\text{bias }}(\boldsymbol{\xi})}{\partial \boldsymbol{\xi}}
  \frac{\partial \boldsymbol{\xi}}{\partial \mathbf{r}_i} \ldots
\end{align}

\noindent โดยที่ $M_i$ คือมวลของอะตอม $i$, $\mathbf{r}_i$ คือตำแหน่งของอะตอม, และ $t$ คือเวลา

การกำหนด CV สำหรับการรันการคำนวณ Metadynamics นั้นสำคัญมาก ๆ โดย CV ที่เรากำหนดนั้นจะต้องสอดคล้องกับปรากฏการณ์ทางเคมีที่เราสนใจ
และ CV นั้นจะต้องเป็นฟังก์ชันที่สามารถแยกสถานะเริ่มต้นและสถานะสิ้นสุดของโมเลกุลได้อย่างชัดเจน หรือที่เรียกว่า Metastable State ตัวอย่างเช่น
ถ้าหากว่าเราอยากจะจำลอง MD ของปฏิกิริยาการสร้างพันธะระหว่างโมเลกุล 2 โมเลกุล สถานะตั้งต้น (Reactant State) กับสถานะผลิตภัณฑ์
(Product State) ก็คือ Metastable State ที่เราสนใจ ซึ่งพารามิเตอร์หรือฟังก์ชันที่เหมาะสมที่จะถูกนำมาใช้เป็น CV ในกรณีนี้ก็คือความยาวพันธะ
(Bond Distance) ระหว่างอะตอมของทั้ง 2 โมเลกุลนั่นเอง

ตัวเลือกของ CV นั้นมีหลากหลายฟังก์ชัน โดยพารามิเตอร์ที่เราจะสามารถใช้ได้นั้นจะต้องเป็นฟังก์ชันที่ขึ้นกับตำแหน่งของอะตอมด้วย

\noindent \textbf{ความยาวพันธะ (Bond Distance)}:
\begin{equation}
  \boldsymbol{\xi}_{dist} = |\mathbf{r}_{G_{1}} - {r}_{G_{2}}|
\end{equation}

\noindent \textbf{มุมพันธะ (Bond Angle)}:
\begin{align*}
  \mathbf{r}_{a} &= \mathbf{r}_{G_{1}} - \mathbf{r}_{G_{2}} \\
  \mathbf{r}_{b} &= \mathbf{r}_{G_{1}} - \mathbf{r}_{G_{3}} \\
  \mathbf{r}_{c} &= \mathbf{r}_{G_{2}} - \mathbf{r}_{G_{3}} \\
  \boldsymbol{\xi}_{angle} 
  &= 
  \text{cos}^{-1} \left( \frac{\mathbf{r}^2_{a} 
    + \mathbf{r}^2_{c} 
    - \mathbf{r}^2_{b}}{2|\mathbf{r}_{a}||\mathbf{r}_{c}|} \right)
\end{align*}

\noindent \textbf{มุมบิด (Torsion Angle)}:
\begin{align*}
  \mathbf{r}_{a} &= \mathbf{r}_{G_{4}} - \mathbf{r}_{G_{3}} \\
  \mathbf{r}_{b} &= \mathbf{r}_{G_{3}} - \mathbf{r}_{G_{3}} \\
  \mathbf{r}_{c} &= \mathbf{r}_{G_{2}} - \mathbf{r}_{G_{2}} \\
  \mathbf{r}_{d} &= \mathbf{r}_{G_{1}} - \mathbf{r}_{G_{2}} \\
  \boldsymbol{\xi}_{torsion} 
  &= 
  \text{cos}^{-1} \left( 
    \frac{(\mathbf{r}_{a} \times \mathbf{r}_{b}) 
      \cdot (\mathbf{r}_{c} \times \mathbf{r}_{d}) }{ 
        |\mathbf{r}_{a} \times \mathbf{r}_{b}) 
          || (\mathbf{r}_{c} \times \mathbf{r}_{d}| } \right)
\end{align*}

\noindent \textbf{Adjacency matrix (Smooth Function)}:

\begin{equation}
  \boldsymbol{\xi}_{A} = \frac{ 1-\left(\frac{|\mathbf{r}_{i} - \mathbf{r}_{j}|}{r_{0}}\right)^n }
  { 1-\left(\frac{|\mathbf{r}_{i} - \mathbf{r}_{j}|}{r_{0}}\right)^m }
\end{equation}

สำหรับโปรแกรมคำนวณ Metadynamics นั้นผู้อ่านสามารถศึกษาได้จากโค้ดด้านล่าง (ภาษา Python) โดยเป็นโค้ดของ Metadynamics อย่างง่าย
(กรณี 1 มิติ)

\vspace{5pt}

\begin{lstlisting}[style=MyPython]
import numpy as np


def energy(h, w, xyz, x, nbump):
    """
    The sum of Gaussian with height h and
    width w at positions xyz sampled at x.
    Use distance matrices to maintain
    rotational invariance.

    Args :
    h : height
    w: width
    xyz : bumps x N x 3 tensor
    x : (n X 3) tensor representing the point
        at which the energy is sampled
    nbump : the number of bumps
    """

    xshp = np.shape(x)
    nx = xshp[0]
    Nzxyz = np.slice(xyz, [0, 0, 0], [nbump, nx, 3])
    Ds = distances(Nzxyz)
    Dx = distances(x)
    w2 = np.square(w)
    rij = Ds - np.tile(np.reshape(Dx, [1, nx, nx]), [nbump, 1, 1])
    ToExp = np.einsum("ijk,ijk−>i", rij, rij)
    ToSum = -1.0 * h * np.exp(-0.5 * ToExp / w2)
    return -1.0 * np.reduce_sum(ToSum, axis=0)


def force(energy, x):
    return np.gradient(energy, x)


def distances(r):
    """
    Calculat edistance matrices
    """
    rm = np.einsum("ijk,ijk->ij", r, r)
    rshp = np.shape(rm)
    rmt = np.tile(rm, [1, rshp[1]])
    rmt = np.reshape(rmy, [rshp[0], rshp[1], rshp[1]])
    rmtt = np.transpose(rmp, perm=[0, 2, 1])
    D = rmt - 2 * np.einsum("ihk,ilk->ijl", r, r) + rmtt + np.cast(1e-28, np.float64)
    return np.sqrt(D)
\end{lstlisting}

\vspace{5pt}

%----------------------------------------
\section{แบบฝึกหัด}
%----------------------------------------

\begin{enumerate}[topsep=0pt,noitemsep]
  \setlength\itemsep{1em}
  \item เขียนโปรแกรมสำหรับจำลองระบบอะตอมเดี่ยวด้วยวิธี Born-Oppenheimer Molecular Dynamics อย่างง่าย

  \item เขียนโปรแกรม Metadynamics สำหรับจำลองระบบโมเลกุลแบบ 1 มิติด้วยภาษา \cpp

  \item เขียนโปรแกรม Metadynamics สำหรับจำลองระบบโมเลกุลแบบ 2 มิติ (ใช้ภาษาอะไรก็ได้และสามารถประยุกต์จากโปรแกรมตัวอย่างได้)
\end{enumerate}
